<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lighter Trades Fetcher</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&family=Outfit:wght@300;400;500;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-primary: #0a0a0f;
            --bg-secondary: #12121a;
            --bg-tertiary: #1a1a24;
            --accent: #00d4aa;
            --accent-dim: #00a888;
            --text-primary: #e8e8ed;
            --text-secondary: #8888a0;
            --border: #2a2a3a;
            --error: #ff5566;
            --success: #00d4aa;
            --warning: #ffaa00;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Outfit', -apple-system, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            line-height: 1.6;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(0, 212, 170, 0.02) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 212, 170, 0.02) 1px, transparent 1px);
            background-size: 50px 50px;
            pointer-events: none;
            z-index: -1;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 40px 24px;
        }

        header {
            text-align: center;
            margin-bottom: 48px;
        }

        h1 {
            font-size: 2.2rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 8px;
            letter-spacing: -0.02em;
        }

        h1 span {
            color: var(--accent);
        }

        .subtitle {
            color: var(--text-secondary);
            font-size: 1rem;
            font-weight: 300;
        }

        .card {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 32px;
            margin-bottom: 24px;
        }

        .card-title {
            font-size: 1rem;
            font-weight: 500;
            color: var(--accent);
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            font-size: 0.85rem;
            font-weight: 500;
            color: var(--text-secondary);
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        input {
            width: 100%;
            padding: 14px 16px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        input:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(0, 212, 170, 0.1);
        }

        input::placeholder {
            color: var(--text-secondary);
            opacity: 0.5;
        }

        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
        }

        @media (max-width: 600px) {
            .form-row {
                grid-template-columns: 1fr;
            }
        }

        button {
            padding: 14px 24px;
            border: none;
            border-radius: 8px;
            font-family: 'Outfit', sans-serif;
            font-size: 0.95rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background: var(--accent);
            color: var(--bg-primary);
        }

        .btn-primary:hover:not(:disabled) {
            background: var(--accent-dim);
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border);
        }

        .btn-secondary:hover:not(:disabled) {
            background: var(--border);
        }

        .btn-small {
            padding: 8px 16px;
            font-size: 0.85rem;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-group {
            display: flex;
            gap: 12px;
            margin-top: 20px;
        }

        .status {
            margin-top: 20px;
            padding: 14px 16px;
            border-radius: 8px;
            font-size: 0.9rem;
            display: none;
        }

        .status.show {
            display: block;
        }

        .status.loading {
            background: rgba(0, 212, 170, 0.1);
            border: 1px solid rgba(0, 212, 170, 0.3);
            color: var(--accent);
        }

        .status.error {
            background: rgba(255, 85, 102, 0.1);
            border: 1px solid rgba(255, 85, 102, 0.3);
            color: var(--error);
        }

        .status.success {
            background: rgba(0, 212, 170, 0.1);
            border: 1px solid rgba(0, 212, 170, 0.3);
            color: var(--success);
        }

        /* Account selection */
        .accounts-list {
            margin-top: 16px;
        }

        .account-item {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 12px;
        }

        .account-item.selected {
            border-color: var(--accent);
        }

        .account-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 12px;
        }

        .account-header input[type="checkbox"] {
            width: 20px;
            height: 20px;
            accent-color: var(--accent);
        }

        .account-header label {
            margin-bottom: 0;
            font-size: 1rem;
            color: var(--text-primary);
        }

        .account-fields {
            display: none;
            padding-top: 12px;
            border-top: 1px solid var(--border);
        }

        .account-item.selected .account-fields {
            display: block;
        }

        /* Column selector */
        .column-selector {
            margin-bottom: 16px;
            padding: 12px;
            background: var(--bg-tertiary);
            border-radius: 8px;
        }

        .column-selector-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            color: var(--text-secondary);
            font-size: 0.85rem;
        }

        .column-selector-header:hover {
            color: var(--text-primary);
        }

        .column-options {
            display: none;
            margin-top: 12px;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .column-selector.expanded .column-options {
            display: flex;
        }

        .column-option {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 6px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .column-option:hover {
            border-color: var(--accent);
        }

        .column-option.active {
            border-color: var(--accent);
            background: rgba(0, 212, 170, 0.1);
        }

        .column-option input {
            width: 14px;
            height: 14px;
            accent-color: var(--accent);
        }

        /* Tabs */
        .tabs {
            display: flex;
            gap: 4px;
            margin-bottom: 16px;
            flex-wrap: wrap;
        }

        .tab {
            padding: 10px 20px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 8px 8px 0 0;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
        }

        .tab:hover {
            background: var(--border);
        }

        .tab.active {
            background: var(--accent);
            color: var(--bg-primary);
            border-color: var(--accent);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .results-header h2 {
            font-size: 1.1rem;
            font-weight: 500;
        }

        .results-stats {
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .results-box {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 16px;
            max-height: 500px;
            overflow-y: auto;
            overflow-x: auto;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            line-height: 1.6;
        }

        .trades-table {
            width: 100%;
            border-collapse: collapse;
            min-width: 800px;
        }

        .trades-table th {
            text-align: left;
            padding: 8px 12px;
            background: var(--bg-secondary);
            color: var(--text-secondary);
            font-weight: 500;
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            border-bottom: 1px solid var(--border);
            position: sticky;
            top: 0;
            z-index: 10;
            overflow: visible;
        }

        .trades-table th:has(.info-icon:hover) {
            z-index: 1002;
            overflow: visible;
        }

        .trades-table thead {
            overflow: visible;
        }

        .trades-table td {
            padding: 8px 12px;
            border-bottom: 1px solid var(--border);
            white-space: nowrap;
        }

        .trades-table tr:hover td {
            background: var(--bg-secondary);
        }

        .trade-market {
            color: var(--accent);
            font-weight: 500;
        }

        .trade-side.long {
            color: #22c55e;
        }

        .trade-side.short {
            color: #ef4444;
        }

        .trade-pnl.profit {
            color: #22c55e;
        }

        .trade-pnl.loss {
            color: #ef4444;
        }

        .tx-hash {
            font-size: 0.7rem;
            color: var(--text-secondary);
            max-width: 120px;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Copyable field styles */
        .copyable {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
            position: relative;
            z-index: 1;
        }

        .copyable:hover {
            color: var(--accent);
        }

        .copy-icon {
            width: 14px;
            height: 14px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .copyable:hover .copy-icon {
            opacity: 1;
        }

        .copy-success {
            color: var(--success) !important;
        }

        /* Info icon and tooltip styles */
        .header-with-info {
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }

        .info-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: var(--border);
            color: var(--text-secondary);
            font-size: 0.6rem;
            font-weight: 600;
            cursor: help;
            position: relative;
            z-index: 1;
        }

        .info-icon:hover {
            background: var(--accent);
            color: var(--bg-primary);
            z-index: 1001;
        }

        .info-tooltip {
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 0.75rem;
            font-weight: 400;
            text-transform: none;
            letter-spacing: normal;
            white-space: normal;
            width: 250px;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s, visibility 0.2s;
            margin-top: 6px;
            line-height: 1.4;
            color: var(--text-secondary);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .info-tooltip a {
            color: var(--accent);
            text-decoration: underline;
        }

        .info-icon:hover .info-tooltip {
            opacity: 1;
            visibility: visible;
        }

        .info-tooltip::before {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-bottom-color: var(--border);
        }

        .security-note {
            margin-top: 32px;
            padding: 16px;
            background: rgba(0, 212, 170, 0.05);
            border: 1px solid rgba(0, 212, 170, 0.2);
            border-radius: 8px;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .security-note strong {
            color: var(--accent);
        }

        .spinner {
            display: inline-block;
            width: 14px;
            height: 14px;
            border: 2px solid transparent;
            border-top-color: currentColor;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin-right: 8px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .results-box::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        .results-box::-webkit-scrollbar-track {
            background: var(--bg-tertiary);
            border-radius: 4px;
        }

        .results-box::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 4px;
        }

        .results-box::-webkit-scrollbar-thumb:hover {
            background: var(--text-secondary);
        }

        .hidden {
            display: none !important;
        }

        .error-message {
            color: var(--error);
            padding: 20px;
            text-align: center;
        }

        /* FAQ Styles */
        .faq-section {
            margin-bottom: 32px;
        }

        .faq-container {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            overflow: hidden;
        }

        .faq-main-toggle {
            padding: 16px 20px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 600;
            font-size: 1rem;
            color: var(--text-primary);
            transition: background 0.2s;
        }

        .faq-main-toggle:hover {
            background: var(--bg-tertiary);
        }

        .faq-items {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.4s ease-out;
        }

        .faq-items.open {
            max-height: 1000px;
        }

        .faq-item {
            background: var(--bg-tertiary);
            margin: 0 12px 8px 12px;
            border-radius: 6px;
            overflow: hidden;
        }

        .faq-item:first-child {
            margin-top: 8px;
        }

        .faq-item:last-child {
            margin-bottom: 12px;
        }

        .faq-question {
            padding: 14px 16px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 500;
            font-size: 0.9rem;
            color: var(--text-primary);
            transition: background 0.2s;
        }

        .faq-question:hover {
            background: rgba(255,255,255,0.03);
        }

        .faq-toggle {
            color: var(--accent);
            font-size: 1.2rem;
            transition: transform 0.3s;
        }

        .faq-container.open > .faq-main-toggle .faq-toggle {
            transform: rotate(45deg);
        }

        .faq-item.open .faq-toggle {
            transform: rotate(45deg);
        }

        .faq-answer {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }

        .faq-item.open .faq-answer {
            max-height: 500px;
        }

        .faq-answer-content {
            padding: 0 16px 14px 16px;
            color: var(--text-secondary);
            font-size: 0.85rem;
            line-height: 1.7;
        }

        .faq-answer-content a {
            color: var(--accent);
        }

        /* Footer */
        .footer {
            text-align: center;
            padding: 24px;
            color: var(--text-secondary);
            font-size: 0.85rem;
        }

        .footer a {
            color: var(--accent);
            text-decoration: none;
            font-weight: 500;
        }

        .footer a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Export <span>Lighter</span> Trading Data</h1>
            <p class="subtitle">Fetch trades, funding, deposits, transfers, and withdrawals</p>
        </header>

        <!-- FAQ Section -->
        <div class="faq-section">
            <div class="faq-container">
                <div class="faq-main-toggle" onclick="toggleFaqSection()">
                    <span>Frequently Asked Questions</span>
                    <span class="faq-toggle" id="faqMainToggle">+</span>
                </div>
                <div class="faq-items" id="faqItems">
                    <div class="faq-item">
                        <div class="faq-question" onclick="toggleFaq(this)">
                            <span>What is a read-only auth token?</span>
                            <span class="faq-toggle">+</span>
                        </div>
                        <div class="faq-answer">
                            <div class="faq-answer-content">
                                A read-only auth token (starting with "ro:") can only be used to fetch data — it cannot trade or withdraw funds. 
                                This is the safest option for exporting your trading history. Generate one at 
                                <a href="https://app.lighter.xyz/read-only-tokens" target="_blank">app.lighter.xyz/read-only-tokens</a>.
                            </div>
                        </div>
                    </div>
                    
                    <div class="faq-item">
                        <div class="faq-question" onclick="toggleFaq(this)">
                            <span>Why do I only need one token for all accounts?</span>
                            <span class="faq-toggle">+</span>
                        </div>
                        <div class="faq-answer">
                            <div class="faq-answer-content">
                                Read-only tokens are scoped to your L1 address, so a single token can access data from all sub-accounts 
                                associated with that address. This makes it easier to export data from multiple accounts at once. Make sure to click on "Allow Sub-account Access" when you generate the token.
                            </div>
                        </div>
                    </div>
                    
                    <div class="faq-item">
                        <div class="faq-question" onclick="toggleFaq(this)">
                            <span>How long will it take to fetch all my trades and funding payments?</span>
                            <span class="faq-toggle">+</span>
                        </div>
                        <div class="faq-answer">
                            <div class="faq-answer-content">
                                To avoid rate limits on the platform, we fetch ~1.7K trades per minute and ~3.6K funding payments per minute. 
                                You should close the Lighter front-end while using this app or you risk getting rate limited. 
                            </div>
                        </div>
                    </div>
                    
                    <div class="faq-item">
                        <div class="faq-question" onclick="toggleFaq(this)">
                            <span>How can I export the data fetched?</span>
                            <span class="faq-toggle">+</span>
                        </div>
                        <div class="faq-answer">
                            <div class="faq-answer-content">
                                You will see the output here in the app, with the option to also download it in a CSV file, or a JSON file 
                                (this will be the raw JSON we fetched from the Lighter servers). Furthermore, you can customize the fields to see and export.
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Step 1: Lookup Accounts -->
        <div class="card" id="step1Card">
            <div class="card-title">Step 1: Lookup Accounts</div>
            <div class="form-group">
                <label for="l1Address">L1 Address</label>
                <input 
                    type="text" 
                    id="l1Address" 
                    placeholder="0x..."
                    required
                >
            </div>
            <button class="btn-primary" id="lookupBtn" onclick="lookupAccounts()">
                Lookup Accounts
            </button>
            <div id="lookupStatus" class="status"></div>
        </div>

        <!-- Step 2: Enter Read-Only Token -->
        <div class="card hidden" id="step2Card">
            <div class="card-title">Step 2: Enter Read-Only Token</div>
            <p style="color: var(--text-secondary); margin-bottom: 16px; font-size: 0.9rem;">
                Enter your read-only auth token. This single token will be used to fetch data from all selected accounts.
                <br><br>
                Generate a read-only token at <a href="https://app.lighter.xyz/read-only-tokens" target="_blank" style="color: var(--accent);">app.lighter.xyz/read-only-tokens</a>
            </p>
            <div class="form-group">
                <label for="readOnlyToken">Read-Only Auth Token</label>
                <input 
                    type="password" 
                    id="readOnlyToken" 
                    placeholder="ro:60973:all:1765479143:90d64052f462..."
                    required
                >
            </div>
            <button class="btn-primary" id="continueBtn" onclick="continueToAccountSelection()">
                Continue
            </button>
            <div id="tokenStatus" class="status"></div>
        </div>

        <!-- Step 3: Select Accounts -->
        <div class="card hidden" id="step3Card">
            <div class="card-title">Step 3: Select Accounts</div>
            <p style="color: var(--text-secondary); margin-bottom: 16px; font-size: 0.9rem;">
                Select the accounts you want to fetch data from.
            </p>
            <div id="accountsList" class="accounts-list"></div>
            
            <div class="btn-group" style="flex-wrap: wrap;">
                <button class="btn-primary" id="fetchTradesBtn" onclick="fetchTrades()">
                    Fetch Trades
                </button>
                <button class="btn-primary" id="fetchFundingBtn" onclick="fetchFunding()">
                    Fetch Funding
                </button>
                <button class="btn-primary" id="fetchDepositsBtn" onclick="fetchDeposits()">
                    Fetch Deposits
                </button>
                <button class="btn-primary" id="fetchTransfersBtn" onclick="fetchTransfers()">
                    Fetch Transfers
                </button>
                <button class="btn-primary" id="fetchWithdrawalsBtn" onclick="fetchWithdrawals()">
                    Fetch Withdrawals
                </button>
            </div>
            <div id="fetchStatus" class="status"></div>
        </div>

        <!-- Step 3: Results -->
        <div class="card hidden" id="resultsCard">
            <div class="card-title">Trade History</div>
            
            <!-- Column Selector -->
            <div class="column-selector expanded" id="columnSelector">
                <div class="column-selector-header" onclick="toggleColumnSelector()">
                    <span>Select Columns to Display/Export</span>
                    <span id="toggleIcon">▼</span>
                </div>
                <div class="column-options" id="columnOptions"></div>
            </div>
            
            <div id="accountTabs" class="tabs"></div>
            <div id="accountContents"></div>
        </div>

        <!-- Funding Payments Results -->
        <div class="card hidden" id="fundingCard">
            <div class="card-title">Funding Payments</div>
            <div id="fundingTabs" class="tabs"></div>
            <div id="fundingContents"></div>
        </div>

        <!-- Deposits Results -->
        <div class="card hidden" id="depositsCard">
            <div class="card-title">Deposits</div>
            <div id="depositsTabs" class="tabs"></div>
            <div id="depositsContents"></div>
        </div>

        <!-- Transfers Results -->
        <div class="card hidden" id="transfersCard">
            <div class="card-title">Transfers</div>
            <!-- Type Filter -->
            <div class="type-filter" id="transferTypeFilter" style="margin-bottom: 16px; padding: 12px; background: var(--bg-tertiary); border-radius: 8px;">
                <div style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 8px;">Filter by Type:</div>
                <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                    <label class="column-option active" onclick="toggleTransferType('L2TransferOutflow')">
                        <input type="checkbox" checked onchange="toggleTransferType('L2TransferOutflow')" onclick="event.stopPropagation()">
                        Outgoing Transfer
                    </label>
                    <label class="column-option active" onclick="toggleTransferType('L2TransferInflow')">
                        <input type="checkbox" checked onchange="toggleTransferType('L2TransferInflow')" onclick="event.stopPropagation()">
                        Incoming Transfer
                    </label>
                    <label class="column-option active" onclick="toggleTransferType('L2SelfTransfer')">
                        <input type="checkbox" checked onchange="toggleTransferType('L2SelfTransfer')" onclick="event.stopPropagation()">
                        Internal Transfer
                    </label>
                    <label class="column-option active" onclick="toggleTransferType('L2MintSharesOutflow')">
                        <input type="checkbox" checked onchange="toggleTransferType('L2MintSharesOutflow')" onclick="event.stopPropagation()">
                        Public Pool Mint
                    </label>
                    <label class="column-option active" onclick="toggleTransferType('L2BurnSharesInflow')">
                        <input type="checkbox" checked onchange="toggleTransferType('L2BurnSharesInflow')" onclick="event.stopPropagation()">
                        Public Pool Burn
                    </label>
                </div>
            </div>
            <div id="transfersTabs" class="tabs"></div>
            <div id="transfersContents"></div>
        </div>

        <!-- Withdrawals Results -->
        <div class="card hidden" id="withdrawalsCard">
            <div class="card-title">Withdrawals</div>
            <div id="withdrawalsTabs" class="tabs"></div>
            <div id="withdrawalsContents"></div>
        </div>

        <div class="security-note">
            <strong>Security Note:</strong> This app uses read-only auth tokens — they can only view data, not trade or withdraw.
            Trade data is fetched directly from your browser to Lighter's API (rate limits apply to your IP). 
            Tokens are never stored or logged.
            This application is <a href="https://github.com/techcobain/Lighter-export-trades" target="_blank" style="color: var(--accent);">open source</a> 
            so you're free to audit the code, and run it locally if you prefer.
        </div>
        
        <div class="footer">
            Built by <a href="https://t.me/heysupertramp" target="_blank">Supertramp</a>
        </div>
    </div>

    <script>
        // ===== SECURITY: HTML Escaping to prevent XSS =====
        function escapeHtml(unsafe) {
            if (unsafe === null || unsafe === undefined) return '';
            return String(unsafe)
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }
        
        // Copy to clipboard function (uses data-copy attribute for safety)
        function copyToClipboard(element) {
            const text = element.dataset.copy;
            if (!text || text === 'null' || text === 'undefined') {
                return;
            }
            navigator.clipboard.writeText(text).then(() => {
                // Visual feedback
                element.classList.add('copy-success');
                const span = element.querySelector('.tx-hash');
                if (span) {
                    const originalText = span.textContent;
                    span.textContent = 'Copied!';
                    setTimeout(() => {
                        span.textContent = originalText;
                        element.classList.remove('copy-success');
                    }, 1000);
                }
            }).catch(err => {
                console.error('Failed to copy:', err);
            });
        }
        
        // SVG icons
        const COPY_ICON_SVG = `<svg class="copy-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>`;
        
        // CSV escape helper - properly escapes values for CSV format
        function csvEscape(value) {
            if (value === null || value === undefined) return '';
            const str = String(value);
            // Escape double quotes by doubling them, wrap in quotes
            return `"${str.replace(/"/g, '""')}"`;
        }
        
        // FAQ Toggle - Main section
        function toggleFaqSection() {
            const container = document.querySelector('.faq-container');
            const items = document.getElementById('faqItems');
            container.classList.toggle('open');
            items.classList.toggle('open');
        }
        
        // FAQ Toggle - Individual items
        function toggleFaq(element) {
            const faqItem = element.parentElement;
            faqItem.classList.toggle('open');
        }
        
        // State
        let accountIndexes = [];
        let readOnlyToken = null; // Single read-only token for all accounts
        let fetchedData = {}; // { accountIndex: { trades: [...], ... } }
        let rawTradesData = {}; // { accountIndex: [raw trades from API] }
        let fundingData = {}; // { accountIndex: { fundings: [...], ... } }
        let rawFundingData = {}; // { accountIndex: [raw funding from API] }
        let depositsData = {}; // { accountIndex: { deposits: [...], ... } }
        let rawDepositsData = {}; // { accountIndex: [raw deposits from API] }
        let transfersData = {}; // { accountIndex: { transfers: [...], ... } }
        let rawTransfersData = {}; // { accountIndex: [raw transfers from API] }
        let withdrawalsData = {}; // { accountIndex: { withdrawals: [...], ... } }
        let rawWithdrawalsData = {}; // { accountIndex: [raw withdrawals from API] }
        
        // Asset cache for mapping asset_id to symbol
        let assetCache = {};
        let assetCacheTimestamp = 0;
        const ASSET_CACHE_TTL = 3600000; // 1 hour in ms
        
        // Transfer type mappings
        const TRANSFER_TYPE_MAP = {
            'L2TransferOutflow': 'Outgoing Transfer',
            'L2BurnSharesInflow': 'Public Pool Burn',
            'L2MintSharesOutflow': 'Public Pool Mint',
            'L2SelfTransfer': 'Internal Transfer',
            'L2TransferInflow': 'Incoming Transfer'
        };
        
        // Transfer type filter state (all enabled by default)
        let transferTypeFilters = {
            'L2TransferOutflow': true,
            'L2BurnSharesInflow': true,
            'L2MintSharesOutflow': true,
            'L2SelfTransfer': true,
            'L2TransferInflow': true
        };
        
        // Fetch asset details and cache them
        async function fetchAssetDetails() {
            const now = Date.now();
            if (Object.keys(assetCache).length > 0 && (now - assetCacheTimestamp) < ASSET_CACHE_TTL) {
                return assetCache;
            }
            
            try {
                const response = await fetch(`${LIGHTER_API}/api/v1/assetDetails`);
                if (response.ok) {
                    const data = await response.json();
                    if (data.code === 200 && data.asset_details) {
                        assetCache = {};
                        data.asset_details.forEach(asset => {
                            assetCache[asset.asset_id] = {
                                symbol: asset.symbol,
                                name: asset.name || asset.symbol,
                                decimals: asset.decimals || 8
                            };
                        });
                        assetCacheTimestamp = now;
                    } else {
                        console.warn('Asset details API returned unexpected format');
                    }
                } else {
                    console.warn(`Asset details fetch failed with status: ${response.status}`);
                }
            } catch (error) {
                console.error('Error fetching asset details:', error);
                // Show warning to user if this is first fetch (no cache)
                if (Object.keys(assetCache).length === 0) {
                    showStatus('fetchStatus', 'Warning: Could not load asset symbols. Asset IDs will be shown instead.', 'loading');
                    await new Promise(r => setTimeout(r, 2000)); // Show for 2 seconds
                }
            }
            return assetCache;
        }
        
        // Get asset symbol by ID
        function getAssetSymbol(assetId) {
            const asset = assetCache[assetId];
            return asset ? asset.symbol : `Asset #${assetId}`;
        }
        
        // All available columns with display names and default visibility
        const ALL_COLUMNS = {
            trade_id: { label: 'Trade ID', default: false },
            tx_hash: { label: 'Tx Hash', default: false },
            market: { label: 'Market', default: true },
            side: { label: 'Side', default: true },
            datetime_utc: { label: 'Date/Time', default: true },
            trade_value_usd: { label: 'Value ($)', default: true },
            size: { label: 'Size', default: true },
            price_usd: { label: 'Price ($)', default: true },
            fee_usd: { label: 'Fee ($)', default: true },
            role: { label: 'Role', default: true },
            trade_type: { label: 'Type', default: true },
            pnl_usd: { label: 'PnL ($)', default: true }
        };
        
        // Track selected columns
        let selectedColumns = {};
        
        // Initialize selected columns from defaults
        function initColumnSelection() {
            Object.keys(ALL_COLUMNS).forEach(col => {
                selectedColumns[col] = ALL_COLUMNS[col].default;
            });
            renderColumnOptions();
        }
        
        // Render column checkboxes
        function renderColumnOptions() {
            const container = document.getElementById('columnOptions');
            container.innerHTML = Object.entries(ALL_COLUMNS).map(([key, config]) => `
                <label class="column-option ${selectedColumns[key] ? 'active' : ''}" onclick="toggleColumn('${key}')">
                    <input type="checkbox" ${selectedColumns[key] ? 'checked' : ''} onchange="toggleColumn('${key}')" onclick="event.stopPropagation()">
                    ${config.label}
                </label>
            `).join('');
        }
        
        // Toggle column visibility
        function toggleColumn(columnKey) {
            selectedColumns[columnKey] = !selectedColumns[columnKey];
            renderColumnOptions();
            // Re-render results if we have data
            if (Object.keys(fetchedData).length > 0) {
                displayResults();
            }
        }
        
        // Toggle column selector expand/collapse
        function toggleColumnSelector() {
            const selector = document.getElementById('columnSelector');
            const icon = document.getElementById('toggleIcon');
            selector.classList.toggle('expanded');
            icon.textContent = selector.classList.contains('expanded') ? '▼' : '▶';
        }
        
        // Get list of visible columns
        function getVisibleColumns() {
            return Object.keys(selectedColumns).filter(col => selectedColumns[col]);
        }

        // Show status message
        function showStatus(elementId, message, type = 'loading') {
            const el = document.getElementById(elementId);
            el.textContent = message;
            el.className = `status show ${type}`;
        }

        function hideStatus(elementId) {
            document.getElementById(elementId).className = 'status';
        }

        // Step 1: Lookup accounts
        async function lookupAccounts() {
            const l1Address = document.getElementById('l1Address').value.trim();
            if (!l1Address) {
                showStatus('lookupStatus', 'Please enter an L1 address', 'error');
                return;
            }

            const btn = document.getElementById('lookupBtn');
            btn.disabled = true;
            btn.innerHTML = '<span class="spinner"></span>Looking up...';
            showStatus('lookupStatus', 'Fetching account indexes...', 'loading');

            try {
                const response = await fetch('/api/lookup-accounts', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ l1_address: l1Address })
                });

                const data = await response.json();
                if (!response.ok) {
                    throw new Error(data.detail || 'Failed to lookup accounts');
                }

                accountIndexes = data.account_indexes;
                showStatus('lookupStatus', `Found ${accountIndexes.length} account(s)`, 'success');
                
                // Show step 2 (read-only token input)
                document.getElementById('step2Card').classList.remove('hidden');

            } catch (error) {
                showStatus('lookupStatus', `Error: ${error.message}`, 'error');
            } finally {
                btn.disabled = false;
                btn.textContent = 'Lookup Accounts';
            }
        }

        // Continue to account selection after entering read-only token
        function continueToAccountSelection() {
            const token = document.getElementById('readOnlyToken').value.trim();
            if (!token) {
                showStatus('tokenStatus', 'Please enter a read-only token', 'error');
                return;
            }
            
            // Validate token format: ro:account_index:scope:expiry:signature
            if (!token.startsWith('ro:')) {
                showStatus('tokenStatus', 'Invalid read-only token format. Token must start with "ro:"', 'error');
                return;
            }
            
            readOnlyToken = token;
            showStatus('tokenStatus', 'Token validated', 'success');
            
            // Build account selection UI
            buildAccountsList();
            document.getElementById('step3Card').classList.remove('hidden');
        }

        // Build accounts list with checkboxes only
        function buildAccountsList() {
            const container = document.getElementById('accountsList');
            container.innerHTML = '';

            accountIndexes.forEach((index, i) => {
                // Validate index is a number to prevent injection
                const safeIndex = parseInt(index, 10);
                if (isNaN(safeIndex)) return;
                
                const isFirst = i === 0;
                const div = document.createElement('div');
                div.className = `account-item ${isFirst ? 'selected' : ''}`;
                div.id = `account-${safeIndex}`;
                div.innerHTML = `
                    <div class="account-header">
                        <input type="checkbox" id="check-${safeIndex}" ${isFirst ? 'checked' : ''} 
                            onchange="toggleAccount(${safeIndex})">
                        <label for="check-${safeIndex}">Account Index: <strong>${safeIndex}</strong></label>
                    </div>
                `;
                container.appendChild(div);
            });
        }

        // Toggle account selection
        function toggleAccount(index) {
            const item = document.getElementById(`account-${index}`);
            const checkbox = document.getElementById(`check-${index}`);
            if (checkbox.checked) {
                item.classList.add('selected');
            } else {
                item.classList.remove('selected');
            }
        }

        // Get selected account indexes
        function getSelectedAccounts() {
            const selected = [];
            accountIndexes.forEach(index => {
                const checkbox = document.getElementById(`check-${index}`);
                if (checkbox && checkbox.checked) {
                    selected.push(parseInt(index, 10));
                }
            });
            return selected;
        }

        // Lighter API base URL
        const LIGHTER_API = 'https://mainnet.zklighter.elliot.ai';
        const RATE_LIMIT_DELAY = 3500; // 3.5s between trade calls (20/min limit)
        const FUNDING_RATE_LIMIT_DELAY = 1000; // 1s between funding calls (60/min limit)
        const WALLET_RATE_LIMIT_DELAY = 1000; // 1s between wallet calls (60/min limit)
        
        // Helper to disable/enable all fetch buttons
        function setAllFetchButtonsDisabled(disabled) {
            ['fetchTradesBtn', 'fetchFundingBtn', 'fetchDepositsBtn', 'fetchTransfersBtn', 'fetchWithdrawalsBtn'].forEach(id => {
                const btn = document.getElementById(id);
                if (btn) btn.disabled = disabled;
            });
        }
        
        
        // Fetch trades from Lighter API directly (client-side)
        // Uses headers for auth token (not visible in URL/console)
        async function fetchTradesFromLighter(authToken, accountIndex) {
            const allTrades = [];
            let cursor = null;
            let page = 0;
            
            while (true) {
                page++;
                const params = new URLSearchParams({
                    account_index: accountIndex,
                    sort_by: 'timestamp',
                    limit: 100
                });
                if (cursor) {
                    params.append('cursor', cursor);
                }
                
                showStatus('fetchStatus', `Account #${accountIndex}: Fetching page ${page}...`, 'loading');
                
                try {
                    const response = await fetch(`${LIGHTER_API}/api/v1/trades?${params}`, {
                        headers: { 'Authorization': authToken }
                    });
                    
                    if (response.status === 429) {
                        showStatus('fetchStatus', `Rate limited, waiting 15s...`, 'loading');
                        await new Promise(r => setTimeout(r, 15000));
                        continue;
                    }
                    
                    if (!response.ok) {
                        console.error(`HTTP error: ${response.status}`);
                        break;
                    }
                    
                    const data = await response.json();
                    if (data.code !== 200) {
                        console.error(`API error: ${data.code}`);
                        break;
                    }
                    
                    const trades = data.trades || [];
                    allTrades.push(...trades);
                    
                    // Check for next page
                    if (!data.next_cursor || trades.length === 0) {
                        break;
                    }
                    
                    cursor = data.next_cursor;
                    
                    // Rate limit delay
                    await new Promise(r => setTimeout(r, RATE_LIMIT_DELAY));
                    
                } catch (error) {
                    console.error(`Error fetching trades: ${error}`);
                    break;
                }
            }
            
            return allTrades;
        }

        // Step 3: Fetch trades
        async function fetchTrades() {
            if (!readOnlyToken) {
                showStatus('fetchStatus', 'Please enter a read-only token first', 'error');
                return;
            }
            
            const selectedAccounts = getSelectedAccounts();
            if (selectedAccounts.length === 0) {
                showStatus('fetchStatus', 'Please select at least one account', 'error');
                return;
            }

            const btn = document.getElementById('fetchTradesBtn');
            setAllFetchButtonsDisabled(true);
            btn.innerHTML = '<span class="spinner"></span>Fetching...';
            
            try {
                // Fetch trades for all selected accounts using the single read-only token
                fetchedData = {};
                rawTradesData = {};
                
                for (const accountIndex of selectedAccounts) {
                    // Fetch raw trades from Lighter
                    const rawTrades = await fetchTradesFromLighter(readOnlyToken, accountIndex);
                    
                    // Store raw trades for JSON export
                    rawTradesData[accountIndex] = rawTrades;
                    
                    // Process trades through our server (adds market names, PnL, etc.)
                    showStatus('fetchStatus', `Processing ${rawTrades.length} trades for account #${accountIndex}...`, 'loading');
                    
                    const processResponse = await fetch('/api/process-trades', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            account_index: accountIndex,
                            trades: rawTrades
                        })
                    });
                    
                    const processedData = await processResponse.json();
                    
                    if (processResponse.ok && processedData.success) {
                        fetchedData[accountIndex] = {
                            success: true,
                            total_trades: processedData.total_trades,
                            trades: processedData.trades
                        };
                    } else {
                        fetchedData[accountIndex] = {
                            success: false,
                            error: processedData.detail || 'Processing failed',
                            total_trades: 0,
                            trades: []
                        };
                    }
                }
                
                // Count total trades
                let totalTrades = 0;
                Object.values(fetchedData).forEach(acc => {
                    totalTrades += acc.total_trades || 0;
                });

                showStatus('fetchStatus', `Successfully fetched ${totalTrades} trades`, 'success');
                
                // Initialize column selection and display results
                initColumnSelection();
                displayResults();
                document.getElementById('resultsCard').classList.remove('hidden');

            } catch (error) {
                showStatus('fetchStatus', `Error: ${error.message}`, 'error');
            } finally {
                setAllFetchButtonsDisabled(false);
                btn.textContent = 'Fetch Trades';
            }
        }

        // Display results with tabs
        function displayResults() {
            const tabsContainer = document.getElementById('accountTabs');
            const contentsContainer = document.getElementById('accountContents');
            tabsContainer.innerHTML = '';
            contentsContainer.innerHTML = '';

            const accountIds = Object.keys(fetchedData);
            const visibleCols = getVisibleColumns();
            
            accountIds.forEach((accountIndex, i) => {
                const accountData = fetchedData[accountIndex];
                const isFirst = i === 0;

                // Create tab
                const tab = document.createElement('div');
                tab.className = `tab ${isFirst ? 'active' : ''}`;
                tab.textContent = `Account #${accountIndex}`;
                tab.onclick = () => switchTab(accountIndex);
                tab.id = `tab-${accountIndex}`;
                tabsContainer.appendChild(tab);

                // Create content
                const content = document.createElement('div');
                content.className = `tab-content ${isFirst ? 'active' : ''}`;
                content.id = `content-${accountIndex}`;

                if (!accountData.success) {
                    content.innerHTML = `<div class="error-message">Error: ${escapeHtml(accountData.error)}</div>`;
                } else if (accountData.trades.length === 0) {
                    content.innerHTML = `<div class="error-message">No trades found for this account</div>`;
                } else {
                    const safeAccountIndex = parseInt(accountIndex, 10);
                    const safeTotal = parseInt(accountData.total_trades, 10) || 0;
                    content.innerHTML = `
                        <div class="results-header">
                            <span class="results-stats">${safeTotal} trades</span>
                            <div style="display: flex; gap: 8px;">
                                <button class="btn-secondary btn-small" onclick="exportCSV(${safeAccountIndex})">
                                    CSV
                                </button>
                                <button class="btn-secondary btn-small" onclick="exportJSON(${safeAccountIndex})">
                                    JSON
                                </button>
                            </div>
                        </div>
                        <div class="results-box">
                            ${buildTradesTable(accountData.trades, visibleCols)}
                        </div>
                    `;
                }

                contentsContainer.appendChild(content);
            });
        }

        // Build trades table HTML
        function buildTradesTable(trades, visibleCols) {
            if (visibleCols.length === 0) {
                return '<p style="color: var(--text-secondary); padding: 20px;">No columns selected. Use the column selector above.</p>';
            }
            
            // Build header
            let html = '<table class="trades-table"><thead><tr>';
            visibleCols.forEach(col => {
                html += `<th>${ALL_COLUMNS[col].label}</th>`;
            });
            html += '</tr></thead><tbody>';
            
            // Build rows
            trades.forEach(trade => {
                html += '<tr>';
                visibleCols.forEach(col => {
                    html += `<td>${formatCell(trade, col)}</td>`;
                });
                html += '</tr>';
            });
            
            html += '</tbody></table>';
            return html;
        }
        
        // Format cell value based on column type (with XSS protection)
        function formatCell(trade, col) {
            const value = trade[col];
            
            switch(col) {
                case 'market':
                    return `<span class="trade-market">${escapeHtml(value)}</span>`;
                case 'side':
                    const safeValue = escapeHtml(value);
                    // Green for buy actions: Open Long, Increase Long, Close Short, Reduce Short, Short > Long
                    // Red for sell actions: Open Short, Increase Short, Close Long, Reduce Long, Long > Short
                    const isBuyAction = ['Open Long', 'Increase Long', 'Close Short', 'Reduce Short', 'Short > Long'].includes(value);
                    const sideClass = isBuyAction ? 'long' : 'short';
                    return `<span class="trade-side ${sideClass}">${safeValue}</span>`;
                case 'trade_value_usd':
                case 'price_usd':
                    const numVal = parseFloat(value) || 0;
                    return `$${numVal.toFixed(2)}`;
                case 'fee_usd':
                    const feeVal = parseFloat(value) || 0;
                    return `$${feeVal.toFixed(4)}`;
                case 'pnl_usd':
                    if (value === null) return '-';
                    const pnlVal = parseFloat(value) || 0;
                    const pnlClass = pnlVal >= 0 ? 'profit' : 'loss';
                    const sign = pnlVal >= 0 ? '+' : '';
                    return `<span class="trade-pnl ${pnlClass}">${sign}$${pnlVal.toFixed(2)}</span>`;
                case 'tx_hash':
                    const safeHash = escapeHtml(value);
                    const shortHash = String(value).substring(0, 16);
                    return `<span class="tx-hash" title="${safeHash}">${escapeHtml(shortHash)}...</span>`;
                case 'trade_id':
                    return escapeHtml(parseInt(value, 10) || value);
                case 'size':
                    const sizeVal = parseFloat(value) || 0;
                    return sizeVal.toString();
                default:
                    return escapeHtml(value);
            }
        }

        // Switch tab
        function switchTab(accountIndex) {
            // Update tabs
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.getElementById(`tab-${accountIndex}`).classList.add('active');

            // Update contents
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            document.getElementById(`content-${accountIndex}`).classList.add('active');
        }

        // Export CSV for a specific account (only selected columns)
        function exportCSV(accountIndex) {
            const accountData = fetchedData[accountIndex];
            if (!accountData || !accountData.trades || accountData.trades.length === 0) {
                alert('No trades to export for this account');
                return;
            }

            const trades = accountData.trades;
            const visibleCols = getVisibleColumns();
            
            if (visibleCols.length === 0) {
                alert('Please select at least one column to export');
                return;
            }
            
            // CSV header
            const headers = visibleCols.map(col => ALL_COLUMNS[col].label);
            
            // Build CSV content
            const csvRows = [headers.join(',')];
            
            for (const trade of trades) {
                const row = visibleCols.map(col => {
                    const value = trade[col];
                    if (value === null || value === undefined) return '';
                    if (typeof value === 'string') return `"${value.replace(/"/g, '""')}"`;
                    return value;
                });
                csvRows.push(row.join(','));
            }
            
            const csvContent = csvRows.join('\n');
            
            // Generate filename
            const now = new Date();
            const timestamp = now.toISOString().replace(/[:.]/g, '-').slice(0, 19);
            const filename = `lighter_trades_account_${accountIndex}_${timestamp}.csv`;

            // Download
            const BOM = '\uFEFF';
            const encodedContent = encodeURIComponent(BOM + csvContent);
            const dataUri = `data:text/csv;charset=utf-8,${encodedContent}`;
            
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = dataUri;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            a.remove();
        }
        
        // Export JSON for a specific account (raw data)
        function exportJSON(accountIndex) {
            const rawTrades = rawTradesData[accountIndex];
            if (!rawTrades || rawTrades.length === 0) {
                alert('No trades to export for this account');
                return;
            }
            
            const jsonContent = JSON.stringify({
                exported_at: new Date().toISOString(),
                account_index: accountIndex,
                total_trades: rawTrades.length,
                trades: rawTrades
            }, null, 2);
            
            // Generate filename
            const now = new Date();
            const timestamp = now.toISOString().replace(/[:.]/g, '-').slice(0, 19);
            const filename = `lighter_trades_account_${accountIndex}_${timestamp}.json`;
            
            // Download
            const blob = new Blob([jsonContent], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            
            setTimeout(() => {
                URL.revokeObjectURL(url);
                a.remove();
            }, 100);
        }
        
        // ===== FUNDING PAYMENTS =====
        
        // Fetch funding from Lighter API
        async function fetchFundingFromLighter(authToken, accountIndex) {
            const allFundings = [];
            let cursor = null;
            let page = 0;
            
            while (true) {
                page++;
                const params = new URLSearchParams({
                    account_index: accountIndex,
                    limit: 100
                });
                if (cursor) {
                    params.append('cursor', cursor);
                }
                
                showStatus('fetchStatus', `Account #${accountIndex}: Fetching funding page ${page}...`, 'loading');
                
                try {
                    const response = await fetch(`${LIGHTER_API}/api/v1/positionFunding?${params}`, {
                        headers: { 'Authorization': authToken }
                    });
                    
                    if (response.status === 429) {
                        showStatus('fundingStatus', `Rate limited, waiting 15s...`, 'loading');
                        await new Promise(r => setTimeout(r, 15000));
                        continue;
                    }
                    
                    if (!response.ok) {
                        console.error(`HTTP error: ${response.status}`);
                        break;
                    }
                    
                    const data = await response.json();
                    if (data.code !== 200) {
                        console.error(`API error: ${data.code}`);
                        break;
                    }
                    
                    const fundings = data.position_fundings || [];
                    allFundings.push(...fundings);
                    
                    if (!data.next_cursor || fundings.length === 0) {
                        break;
                    }
                    
                    cursor = data.next_cursor;
                    await new Promise(r => setTimeout(r, FUNDING_RATE_LIMIT_DELAY));
                    
                } catch (error) {
                    console.error(`Error fetching funding: ${error}`);
                    break;
                }
            }
            
            return allFundings;
        }
        
        // Fetch funding for all selected accounts
        async function fetchFunding() {
            if (!readOnlyToken) {
                showStatus('fetchStatus', 'Please enter a read-only token first', 'error');
                return;
            }
            
            const selectedAccounts = getSelectedAccounts();
            if (selectedAccounts.length === 0) {
                showStatus('fetchStatus', 'Please select at least one account', 'error');
                return;
            }
            
            const btn = document.getElementById('fetchFundingBtn');
            setAllFetchButtonsDisabled(true);
            btn.innerHTML = '<span class="spinner"></span>Fetching...';
            
            try {
                fundingData = {};
                rawFundingData = {};
                
                for (const accountIndex of selectedAccounts) {
                    const rawFundings = await fetchFundingFromLighter(readOnlyToken, accountIndex);
                    rawFundingData[accountIndex] = rawFundings;
                    
                    // Process funding data
                    const processed = await processFundingData(rawFundings, accountIndex);
                    fundingData[accountIndex] = {
                        success: true,
                        total_fundings: processed.length,
                        fundings: processed
                    };
                }
                
                let totalFundings = 0;
                Object.values(fundingData).forEach(acc => {
                    totalFundings += acc.total_fundings || 0;
                });
                
                showStatus('fetchStatus', `Successfully fetched ${totalFundings} funding payments`, 'success');
                displayFundingResults();
                document.getElementById('fundingCard').classList.remove('hidden');
                
            } catch (error) {
                showStatus('fetchStatus', `Error: ${error.message}`, 'error');
            } finally {
                setAllFetchButtonsDisabled(false);
                btn.textContent = 'Fetch Funding';
            }
        }
        
        // Process funding data (add market names, format values)
        async function processFundingData(rawFundings, accountIndex) {
            // Get market map from server
            const response = await fetch('/api/markets');
            const marketData = await response.json();
            const marketMap = marketData.markets || {};
            
            return rawFundings.map(f => {
                const marketName = marketMap[f.market_id] || `ID:${f.market_id}`;
                const timestamp = f.timestamp * 1000; // Convert to ms
                const dt = new Date(timestamp);
                const dateStr = dt.toISOString().replace('T', ' ').slice(0, 19) + ' UTC';
                
                return {
                    funding_id: f.funding_id,
                    market: marketName,
                    datetime_utc: dateStr,
                    change_usd: parseFloat(f.change),
                    rate_percent: (parseFloat(f.rate) * 100).toFixed(4),
                    size: parseFloat(f.position_size),
                    side: f.position_side
                };
            });
        }
        
        // Display funding results
        function displayFundingResults() {
            const tabsContainer = document.getElementById('fundingTabs');
            const contentsContainer = document.getElementById('fundingContents');
            tabsContainer.innerHTML = '';
            contentsContainer.innerHTML = '';
            
            const accountIds = Object.keys(fundingData);
            
            accountIds.forEach((accountIndex, i) => {
                const accountData = fundingData[accountIndex];
                const isFirst = i === 0;
                
                // Create tab
                const tab = document.createElement('div');
                tab.className = `tab ${isFirst ? 'active' : ''}`;
                tab.textContent = `Account #${accountIndex}`;
                tab.onclick = () => switchFundingTab(accountIndex);
                tab.id = `funding-tab-${accountIndex}`;
                tabsContainer.appendChild(tab);
                
                // Create content
                const content = document.createElement('div');
                content.className = `tab-content ${isFirst ? 'active' : ''}`;
                content.id = `funding-content-${accountIndex}`;
                
                if (!accountData.success || accountData.fundings.length === 0) {
                    content.innerHTML = `<div class="error-message">No funding payments found</div>`;
                } else {
                    const safeAccountIndex = parseInt(accountIndex, 10);
                    const safeTotal = parseInt(accountData.total_fundings, 10) || 0;
                    content.innerHTML = `
                        <div class="results-header">
                            <span class="results-stats">${safeTotal} funding payments</span>
                            <div style="display: flex; gap: 8px;">
                                <button class="btn-secondary btn-small" onclick="exportFundingCSV(${safeAccountIndex})">
                                    CSV
                                </button>
                                <button class="btn-secondary btn-small" onclick="exportFundingJSON(${safeAccountIndex})">
                                    JSON
                                </button>
                            </div>
                        </div>
                        <div class="results-box">
                            ${buildFundingTable(accountData.fundings)}
                        </div>
                    `;
                }
                
                contentsContainer.appendChild(content);
            });
        }
        
        // Build funding table (with XSS protection)
        function buildFundingTable(fundings) {
            let html = '<table class="trades-table"><thead><tr>';
            html += '<th>Market</th><th>Date/Time</th><th>Change ($)</th><th>Rate (%)</th><th>Size</th><th>Side</th>';
            html += '</tr></thead><tbody>';
            
            fundings.forEach(f => {
                const changeVal = parseFloat(f.change_usd) || 0;
                const changeClass = changeVal >= 0 ? 'profit' : 'loss';
                const changeSign = changeVal >= 0 ? '+' : '';
                const safeSide = String(f.side || '').toLowerCase();
                const sideClass = safeSide === 'long' ? 'long' : 'short';
                const sizeVal = parseFloat(f.size) || 0;
                const rateVal = escapeHtml(f.rate_percent);
                
                html += `<tr>
                    <td><span class="trade-market">${escapeHtml(f.market)}</span></td>
                    <td>${escapeHtml(f.datetime_utc)}</td>
                    <td><span class="trade-pnl ${changeClass}">${changeSign}$${changeVal.toFixed(6)}</span></td>
                    <td>${rateVal}%</td>
                    <td>${sizeVal}</td>
                    <td><span class="trade-side ${sideClass}">${escapeHtml(f.side)}</span></td>
                </tr>`;
            });
            
            html += '</tbody></table>';
            return html;
        }
        
        // Switch funding tab
        function switchFundingTab(accountIndex) {
            document.querySelectorAll('#fundingTabs .tab').forEach(t => t.classList.remove('active'));
            document.getElementById(`funding-tab-${accountIndex}`).classList.add('active');
            
            document.querySelectorAll('#fundingContents .tab-content').forEach(c => c.classList.remove('active'));
            document.getElementById(`funding-content-${accountIndex}`).classList.add('active');
        }
        
        // Export funding as CSV
        function exportFundingCSV(accountIndex) {
            const data = fundingData[accountIndex];
            if (!data || !data.fundings || data.fundings.length === 0) {
                alert('No funding to export');
                return;
            }
            
            const headers = ['Market', 'Date/Time', 'Change ($)', 'Rate (%)', 'Size', 'Side'];
            const csvRows = [headers.join(',')];
            
            data.fundings.forEach(f => {
                csvRows.push([
                    `"${f.market}"`,
                    `"${f.datetime_utc}"`,
                    f.change_usd,
                    f.rate_percent,
                    f.size,
                    `"${f.side}"`
                ].join(','));
            });
            
            const csvContent = csvRows.join('\n');
            const now = new Date();
            const timestamp = now.toISOString().replace(/[:.]/g, '-').slice(0, 19);
            const filename = `lighter_funding_account_${accountIndex}_${timestamp}.csv`;
            
            const BOM = '\uFEFF';
            const encodedContent = encodeURIComponent(BOM + csvContent);
            const dataUri = `data:text/csv;charset=utf-8,${encodedContent}`;
            
            const a = document.createElement('a');
            a.href = dataUri;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            a.remove();
        }
        
        // Export funding as JSON
        function exportFundingJSON(accountIndex) {
            const rawFundings = rawFundingData[accountIndex];
            if (!rawFundings || rawFundings.length === 0) {
                alert('No funding to export');
                return;
            }
            
            const jsonContent = JSON.stringify({
                exported_at: new Date().toISOString(),
                account_index: parseInt(accountIndex),
                total_fundings: rawFundings.length,
                position_fundings: rawFundings
            }, null, 2);
            
            const now = new Date();
            const timestamp = now.toISOString().replace(/[:.]/g, '-').slice(0, 19);
            const filename = `lighter_funding_account_${accountIndex}_${timestamp}.json`;
            
            const blob = new Blob([jsonContent], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            
            setTimeout(() => {
                URL.revokeObjectURL(url);
                a.remove();
            }, 100);
        }
        
        // ===== DEPOSITS =====
        
        // Get L1 address from input
        function getL1Address() {
            return document.getElementById('l1Address').value.trim();
        }
        
        // Fetch deposits from Lighter API
        async function fetchDepositsFromLighter(authToken, accountIndex) {
            const allDeposits = [];
            let cursor = null;
            let page = 0;
            const l1Address = getL1Address();
            
            while (true) {
                page++;
                const params = new URLSearchParams({
                    account_index: accountIndex,
                    l1_address: l1Address
                });
                if (cursor) {
                    params.append('cursor', cursor);
                }
                
                showStatus('fetchStatus', `Account #${accountIndex}: Fetching deposits page ${page}...`, 'loading');
                
                try {
                    const response = await fetch(`${LIGHTER_API}/api/v1/deposit/history?${params}`, {
                        headers: { 'Authorization': authToken }
                    });
                    
                    if (response.status === 429) {
                        showStatus('fetchStatus', `Rate limited, waiting 15s...`, 'loading');
                        await new Promise(r => setTimeout(r, 15000));
                        continue;
                    }
                    
                    if (!response.ok) {
                        console.error(`HTTP error: ${response.status}`);
                        break;
                    }
                    
                    const data = await response.json();
                    if (data.code !== 200) {
                        console.error(`API error: ${data.code}`);
                        break;
                    }
                    
                    const deposits = data.deposits || [];
                    allDeposits.push(...deposits);
                    
                    if (!data.cursor || deposits.length === 0) {
                        break;
                    }
                    
                    cursor = data.cursor;
                    await new Promise(r => setTimeout(r, WALLET_RATE_LIMIT_DELAY));
                    
                } catch (error) {
                    console.error(`Error fetching deposits: ${error}`);
                    break;
                }
            }
            
            return allDeposits;
        }
        
        // Fetch deposits for all selected accounts
        async function fetchDeposits() {
            if (!readOnlyToken) {
                showStatus('fetchStatus', 'Please enter a read-only token first', 'error');
                return;
            }
            
            const selectedAccounts = getSelectedAccounts();
            if (selectedAccounts.length === 0) {
                showStatus('fetchStatus', 'Please select at least one account', 'error');
                return;
            }
            
            const btn = document.getElementById('fetchDepositsBtn');
            setAllFetchButtonsDisabled(true);
            btn.innerHTML = '<span class="spinner"></span>Fetching...';
            
            try {
                // Fetch asset details first
                await fetchAssetDetails();
                
                depositsData = {};
                rawDepositsData = {};
                
                for (const accountIndex of selectedAccounts) {
                    const rawDeposits = await fetchDepositsFromLighter(readOnlyToken, accountIndex);
                    rawDepositsData[accountIndex] = rawDeposits;
                    
                    // Process deposits
                    const processed = processDeposits(rawDeposits);
                    depositsData[accountIndex] = {
                        success: true,
                        total_deposits: processed.length,
                        deposits: processed
                    };
                }
                
                let totalDeposits = 0;
                Object.values(depositsData).forEach(acc => {
                    totalDeposits += acc.total_deposits || 0;
                });
                
                showStatus('fetchStatus', `Successfully fetched ${totalDeposits} deposits`, 'success');
                displayDepositsResults();
                document.getElementById('depositsCard').classList.remove('hidden');
                
            } catch (error) {
                showStatus('fetchStatus', `Error: ${error.message}`, 'error');
            } finally {
                setAllFetchButtonsDisabled(false);
                btn.textContent = 'Fetch Deposits';
            }
        }
        
        // Process deposits data
        function processDeposits(rawDeposits) {
            return rawDeposits.map(d => {
                const timestamp = d.timestamp;
                const dt = new Date(timestamp);
                const dateStr = dt.toISOString().replace('T', ' ').slice(0, 19) + ' UTC';
                
                return {
                    id: d.id,
                    asset: getAssetSymbol(d.asset_id),
                    amount: d.amount,
                    datetime_utc: dateStr,
                    l1_tx_hash: d.l1_tx_hash
                };
            });
        }
        
        // Display deposits results
        function displayDepositsResults() {
            const tabsContainer = document.getElementById('depositsTabs');
            const contentsContainer = document.getElementById('depositsContents');
            tabsContainer.innerHTML = '';
            contentsContainer.innerHTML = '';
            
            const accountIds = Object.keys(depositsData);
            
            accountIds.forEach((accountIndex, i) => {
                const accountData = depositsData[accountIndex];
                const isFirst = i === 0;
                
                // Create tab
                const tab = document.createElement('div');
                tab.className = `tab ${isFirst ? 'active' : ''}`;
                tab.textContent = `Account #${accountIndex}`;
                tab.onclick = () => switchDepositsTab(accountIndex);
                tab.id = `deposits-tab-${accountIndex}`;
                tabsContainer.appendChild(tab);
                
                // Create content
                const content = document.createElement('div');
                content.className = `tab-content ${isFirst ? 'active' : ''}`;
                content.id = `deposits-content-${accountIndex}`;
                
                if (!accountData.success || accountData.deposits.length === 0) {
                    content.innerHTML = `<div class="error-message">No deposits found</div>`;
                } else {
                    const safeAccountIndex = parseInt(accountIndex, 10);
                    const safeTotal = parseInt(accountData.total_deposits, 10) || 0;
                    content.innerHTML = `
                        <div class="results-header">
                            <span class="results-stats">${safeTotal} deposits</span>
                            <div style="display: flex; gap: 8px;">
                                <button class="btn-secondary btn-small" onclick="exportDepositsCSV(${safeAccountIndex})">
                                    CSV
                                </button>
                                <button class="btn-secondary btn-small" onclick="exportDepositsJSON(${safeAccountIndex})">
                                    JSON
                                </button>
                            </div>
                        </div>
                        <div class="results-box">
                            ${buildDepositsTable(accountData.deposits)}
                        </div>
                    `;
                }
                
                contentsContainer.appendChild(content);
            });
        }
        
        // Build deposits table
        function buildDepositsTable(deposits) {
            let html = '<table class="trades-table"><thead><tr>';
            html += `<th>ID</th><th>Asset</th><th>Amount</th><th>Time (UTC)</th>
                <th><span class="header-with-info">Transaction Hash (L1)
                    <span class="info-icon">i<span class="info-tooltip">Deposits are always processed on Ethereum. If you select to deposit from different chains, Lighter will bridge them using e.g. CCTP</span></span>
                </span></th>`;
            html += '</tr></thead><tbody>';
            
            deposits.forEach(d => {
                const hash = d.l1_tx_hash || '';
                const shortHash = hash ? hash.substring(0, 16) + '...' : 'N/A';
                const safeHash = escapeHtml(hash);
                html += `<tr>
                    <td>${escapeHtml(d.id)}</td>
                    <td><span class="trade-market">${escapeHtml(d.asset)}</span></td>
                    <td>${escapeHtml(d.amount)}</td>
                    <td>${escapeHtml(d.datetime_utc)}</td>
                    <td>${hash ? `<span class="copyable" data-copy="${safeHash}" onclick="copyToClipboard(this)" title="Click to copy">
                        <span class="tx-hash">${escapeHtml(shortHash)}</span>${COPY_ICON_SVG}
                    </span>` : '<span class="tx-hash">N/A</span>'}</td>
                </tr>`;
            });
            
            html += '</tbody></table>';
            return html;
        }
        
        // Switch deposits tab
        function switchDepositsTab(accountIndex) {
            document.querySelectorAll('#depositsTabs .tab').forEach(t => t.classList.remove('active'));
            document.getElementById(`deposits-tab-${accountIndex}`).classList.add('active');
            
            document.querySelectorAll('#depositsContents .tab-content').forEach(c => c.classList.remove('active'));
            document.getElementById(`deposits-content-${accountIndex}`).classList.add('active');
        }
        
        // Export deposits as CSV
        function exportDepositsCSV(accountIndex) {
            const data = depositsData[accountIndex];
            if (!data || !data.deposits || data.deposits.length === 0) {
                alert('No deposits to export');
                return;
            }
            
            const headers = ['ID', 'Asset', 'Amount', 'Time (UTC)', 'Transaction Hash (L1)'];
            const csvRows = [headers.join(',')];
            
            data.deposits.forEach(d => {
                csvRows.push([
                    csvEscape(d.id),
                    csvEscape(d.asset),
                    csvEscape(d.amount),
                    csvEscape(d.datetime_utc),
                    csvEscape(d.l1_tx_hash)
                ].join(','));
            });
            
            const csvContent = csvRows.join('\n');
            const now = new Date();
            const timestamp = now.toISOString().replace(/[:.]/g, '-').slice(0, 19);
            const filename = `lighter_deposits_account_${accountIndex}_${timestamp}.csv`;
            
            const BOM = '\uFEFF';
            const encodedContent = encodeURIComponent(BOM + csvContent);
            const dataUri = `data:text/csv;charset=utf-8,${encodedContent}`;
            
            const a = document.createElement('a');
            a.href = dataUri;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            a.remove();
        }
        
        // Export deposits as JSON
        function exportDepositsJSON(accountIndex) {
            const rawDeposits = rawDepositsData[accountIndex];
            if (!rawDeposits || rawDeposits.length === 0) {
                alert('No deposits to export');
                return;
            }
            
            const jsonContent = JSON.stringify({
                exported_at: new Date().toISOString(),
                account_index: parseInt(accountIndex),
                total_deposits: rawDeposits.length,
                deposits: rawDeposits
            }, null, 2);
            
            const now = new Date();
            const timestamp = now.toISOString().replace(/[:.]/g, '-').slice(0, 19);
            const filename = `lighter_deposits_account_${accountIndex}_${timestamp}.json`;
            
            const blob = new Blob([jsonContent], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            
            setTimeout(() => {
                URL.revokeObjectURL(url);
                a.remove();
            }, 100);
        }
        
        // ===== TRANSFERS =====
        
        // Toggle transfer type filter
        function toggleTransferType(type) {
            transferTypeFilters[type] = !transferTypeFilters[type];
            
            // Update UI checkbox state
            const filterContainer = document.getElementById('transferTypeFilter');
            const labels = filterContainer.querySelectorAll('.column-option');
            labels.forEach(label => {
                const checkbox = label.querySelector('input');
                const labelText = label.textContent.trim();
                const mappedType = Object.entries(TRANSFER_TYPE_MAP).find(([k, v]) => v === labelText);
                if (mappedType) {
                    const isActive = transferTypeFilters[mappedType[0]];
                    checkbox.checked = isActive;
                    if (isActive) {
                        label.classList.add('active');
                    } else {
                        label.classList.remove('active');
                    }
                }
            });
            
            // Re-render if we have data
            if (Object.keys(transfersData).length > 0) {
                displayTransfersResults();
            }
        }
        
        // Fetch transfers from Lighter API
        async function fetchTransfersFromLighter(authToken, accountIndex) {
            const allTransfers = [];
            let cursor = null;
            let page = 0;
            
            while (true) {
                page++;
                const params = new URLSearchParams({
                    account_index: accountIndex
                });
                if (cursor) {
                    params.append('cursor', cursor);
                }
                
                showStatus('fetchStatus', `Account #${accountIndex}: Fetching transfers page ${page}...`, 'loading');
                
                try {
                    const response = await fetch(`${LIGHTER_API}/api/v1/transfer/history?${params}`, {
                        headers: { 'Authorization': authToken }
                    });
                    
                    if (response.status === 429) {
                        showStatus('fetchStatus', `Rate limited, waiting 15s...`, 'loading');
                        await new Promise(r => setTimeout(r, 15000));
                        continue;
                    }
                    
                    if (!response.ok) {
                        console.error(`HTTP error: ${response.status}`);
                        break;
                    }
                    
                    const data = await response.json();
                    if (data.code !== 200) {
                        console.error(`API error: ${data.code}`);
                        break;
                    }
                    
                    const transfers = data.transfers || [];
                    allTransfers.push(...transfers);
                    
                    if (!data.cursor || transfers.length === 0) {
                        break;
                    }
                    
                    cursor = data.cursor;
                    await new Promise(r => setTimeout(r, WALLET_RATE_LIMIT_DELAY));
                    
                } catch (error) {
                    console.error(`Error fetching transfers: ${error}`);
                    break;
                }
            }
            
            return allTransfers;
        }
        
        // Fetch transfers for all selected accounts
        async function fetchTransfers() {
            if (!readOnlyToken) {
                showStatus('fetchStatus', 'Please enter a read-only token first', 'error');
                return;
            }
            
            const selectedAccounts = getSelectedAccounts();
            if (selectedAccounts.length === 0) {
                showStatus('fetchStatus', 'Please select at least one account', 'error');
                return;
            }
            
            const btn = document.getElementById('fetchTransfersBtn');
            setAllFetchButtonsDisabled(true);
            btn.innerHTML = '<span class="spinner"></span>Fetching...';
            
            try {
                // Fetch asset details first
                await fetchAssetDetails();
                
                transfersData = {};
                rawTransfersData = {};
                
                for (const accountIndex of selectedAccounts) {
                    const rawTransfers = await fetchTransfersFromLighter(readOnlyToken, accountIndex);
                    rawTransfersData[accountIndex] = rawTransfers;
                    
                    // Process transfers
                    const processed = processTransfers(rawTransfers);
                    transfersData[accountIndex] = {
                        success: true,
                        total_transfers: processed.length,
                        transfers: processed
                    };
                }
                
                let totalTransfers = 0;
                Object.values(transfersData).forEach(acc => {
                    totalTransfers += acc.total_transfers || 0;
                });
                
                showStatus('fetchStatus', `Successfully fetched ${totalTransfers} transfers`, 'success');
                displayTransfersResults();
                document.getElementById('transfersCard').classList.remove('hidden');
                
            } catch (error) {
                showStatus('fetchStatus', `Error: ${error.message}`, 'error');
            } finally {
                setAllFetchButtonsDisabled(false);
                btn.textContent = 'Fetch Transfers';
            }
        }
        
        // Process transfers data
        function processTransfers(rawTransfers) {
            return rawTransfers.map(t => {
                const timestamp = t.timestamp;
                const dt = new Date(timestamp);
                const dateStr = dt.toISOString().replace('T', ' ').slice(0, 19) + ' UTC';
                
                // Map type to friendly name
                const typeLabel = TRANSFER_TYPE_MAP[t.type] || t.type;
                
                return {
                    id: t.id,
                    asset: getAssetSymbol(t.asset_id),
                    amount: t.amount,
                    fee: t.fee,
                    datetime_utc: dateStr,
                    type: typeLabel,
                    raw_type: t.type, // Keep raw type for filtering
                    from_l1_address: t.from_l1_address,
                    to_l1_address: t.to_l1_address,
                    from_account_index: t.from_account_index,
                    to_account_index: t.to_account_index,
                    from_route: t.from_route,
                    to_route: t.to_route,
                    tx_hash: t.tx_hash
                };
            });
        }
        
        // Get filtered transfers based on type filters
        function getFilteredTransfers(transfers) {
            return transfers.filter(t => transferTypeFilters[t.raw_type]);
        }
        
        // Display transfers results
        function displayTransfersResults() {
            const tabsContainer = document.getElementById('transfersTabs');
            const contentsContainer = document.getElementById('transfersContents');
            tabsContainer.innerHTML = '';
            contentsContainer.innerHTML = '';
            
            const accountIds = Object.keys(transfersData);
            
            accountIds.forEach((accountIndex, i) => {
                const accountData = transfersData[accountIndex];
                const isFirst = i === 0;
                
                // Create tab
                const tab = document.createElement('div');
                tab.className = `tab ${isFirst ? 'active' : ''}`;
                tab.textContent = `Account #${accountIndex}`;
                tab.onclick = () => switchTransfersTab(accountIndex);
                tab.id = `transfers-tab-${accountIndex}`;
                tabsContainer.appendChild(tab);
                
                // Create content
                const content = document.createElement('div');
                content.className = `tab-content ${isFirst ? 'active' : ''}`;
                content.id = `transfers-content-${accountIndex}`;
                
                const filteredTransfers = getFilteredTransfers(accountData.transfers);
                
                if (!accountData.success || filteredTransfers.length === 0) {
                    content.innerHTML = `<div class="error-message">No transfers found (check type filters above)</div>`;
                } else {
                    const safeAccountIndex = parseInt(accountIndex, 10);
                    content.innerHTML = `
                        <div class="results-header">
                            <span class="results-stats">${filteredTransfers.length} transfers (${accountData.total_transfers} total)</span>
                            <div style="display: flex; gap: 8px;">
                                <button class="btn-secondary btn-small" onclick="exportTransfersCSV(${safeAccountIndex})">
                                    CSV
                                </button>
                                <button class="btn-secondary btn-small" onclick="exportTransfersJSON(${safeAccountIndex})">
                                    JSON
                                </button>
                            </div>
                        </div>
                        <div class="results-box">
                            ${buildTransfersTable(filteredTransfers)}
                        </div>
                    `;
                }
                
                contentsContainer.appendChild(content);
            });
        }
        
        // Build transfers table
        function buildTransfersTable(transfers) {
            let html = '<table class="trades-table"><thead><tr>';
            html += '<th>ID</th><th>Asset</th><th>Amount</th><th>Fee</th><th>Time (UTC)</th><th>Type</th>';
            html += `<th>From Address</th><th>To Address</th><th>From Account</th><th>To Account</th>
                <th>From Route</th><th>To Route</th>
                <th><span class="header-with-info">Transaction Hash (L2)
                    <span class="info-icon">i<span class="info-tooltip">These transactions are processed solely on Lighter's app-chain, to verify them you can use the <a href="https://app.lighter.xyz/explorer" target="_blank">Lighter explorer</a></span></span>
                </span></th>`;
            html += '</tr></thead><tbody>';
            
            transfers.forEach(t => {
                const fromAddr = t.from_l1_address || '';
                const toAddr = t.to_l1_address || '';
                const txHash = t.tx_hash || '';
                const shortFromAddr = fromAddr ? fromAddr.substring(0, 10) + '...' : 'N/A';
                const shortToAddr = toAddr ? toAddr.substring(0, 10) + '...' : 'N/A';
                const shortHash = txHash ? txHash.substring(0, 16) + '...' : 'N/A';
                
                // Color type based on direction
                let typeClass = '';
                if (t.type.includes('Outgoing') || t.type.includes('Mint')) {
                    typeClass = 'short'; // Red for outgoing
                } else if (t.type.includes('Incoming') || t.type.includes('Burn')) {
                    typeClass = 'long'; // Green for incoming
                }
                
                html += `<tr>
                    <td>${escapeHtml(t.id)}</td>
                    <td><span class="trade-market">${escapeHtml(t.asset)}</span></td>
                    <td>${escapeHtml(t.amount)}</td>
                    <td>${escapeHtml(t.fee)}</td>
                    <td>${escapeHtml(t.datetime_utc)}</td>
                    <td><span class="trade-side ${typeClass}">${escapeHtml(t.type)}</span></td>
                    <td>${fromAddr ? `<span class="copyable" data-copy="${escapeHtml(fromAddr)}" onclick="copyToClipboard(this)" title="Click to copy">
                        <span class="tx-hash">${escapeHtml(shortFromAddr)}</span>${COPY_ICON_SVG}
                    </span>` : '<span class="tx-hash">N/A</span>'}</td>
                    <td>${toAddr ? `<span class="copyable" data-copy="${escapeHtml(toAddr)}" onclick="copyToClipboard(this)" title="Click to copy">
                        <span class="tx-hash">${escapeHtml(shortToAddr)}</span>${COPY_ICON_SVG}
                    </span>` : '<span class="tx-hash">N/A</span>'}</td>
                    <td>${escapeHtml(t.from_account_index)}</td>
                    <td>${escapeHtml(t.to_account_index)}</td>
                    <td>${escapeHtml(t.from_route)}</td>
                    <td>${escapeHtml(t.to_route)}</td>
                    <td>${txHash ? `<span class="copyable" data-copy="${escapeHtml(txHash)}" onclick="copyToClipboard(this)" title="Click to copy">
                        <span class="tx-hash">${escapeHtml(shortHash)}</span>${COPY_ICON_SVG}
                    </span>` : '<span class="tx-hash">N/A</span>'}</td>
                </tr>`;
            });
            
            html += '</tbody></table>';
            return html;
        }
        
        // Switch transfers tab
        function switchTransfersTab(accountIndex) {
            document.querySelectorAll('#transfersTabs .tab').forEach(t => t.classList.remove('active'));
            document.getElementById(`transfers-tab-${accountIndex}`).classList.add('active');
            
            document.querySelectorAll('#transfersContents .tab-content').forEach(c => c.classList.remove('active'));
            document.getElementById(`transfers-content-${accountIndex}`).classList.add('active');
        }
        
        // Export transfers as CSV (only filtered types)
        function exportTransfersCSV(accountIndex) {
            const data = transfersData[accountIndex];
            if (!data || !data.transfers || data.transfers.length === 0) {
                alert('No transfers to export');
                return;
            }
            
            const filteredTransfers = getFilteredTransfers(data.transfers);
            if (filteredTransfers.length === 0) {
                alert('No transfers match the current type filters');
                return;
            }
            
            const headers = ['ID', 'Asset', 'Amount', 'Fee', 'Time (UTC)', 'Type', 'From Address', 'To Address', 'From Account', 'To Account', 'From Route', 'To Route', 'Transaction Hash (L2)'];
            const csvRows = [headers.join(',')];
            
            filteredTransfers.forEach(t => {
                csvRows.push([
                    csvEscape(t.id),
                    csvEscape(t.asset),
                    csvEscape(t.amount),
                    csvEscape(t.fee),
                    csvEscape(t.datetime_utc),
                    csvEscape(t.type),
                    csvEscape(t.from_l1_address),
                    csvEscape(t.to_l1_address),
                    csvEscape(t.from_account_index),
                    csvEscape(t.to_account_index),
                    csvEscape(t.from_route),
                    csvEscape(t.to_route),
                    csvEscape(t.tx_hash)
                ].join(','));
            });
            
            const csvContent = csvRows.join('\n');
            const now = new Date();
            const timestamp = now.toISOString().replace(/[:.]/g, '-').slice(0, 19);
            const filename = `lighter_transfers_account_${accountIndex}_${timestamp}.csv`;
            
            const BOM = '\uFEFF';
            const encodedContent = encodeURIComponent(BOM + csvContent);
            const dataUri = `data:text/csv;charset=utf-8,${encodedContent}`;
            
            const a = document.createElement('a');
            a.href = dataUri;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            a.remove();
        }
        
        // Export transfers as JSON
        function exportTransfersJSON(accountIndex) {
            const rawTransfers = rawTransfersData[accountIndex];
            if (!rawTransfers || rawTransfers.length === 0) {
                alert('No transfers to export');
                return;
            }
            
            const jsonContent = JSON.stringify({
                exported_at: new Date().toISOString(),
                account_index: parseInt(accountIndex),
                total_transfers: rawTransfers.length,
                transfers: rawTransfers
            }, null, 2);
            
            const now = new Date();
            const timestamp = now.toISOString().replace(/[:.]/g, '-').slice(0, 19);
            const filename = `lighter_transfers_account_${accountIndex}_${timestamp}.json`;
            
            const blob = new Blob([jsonContent], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            
            setTimeout(() => {
                URL.revokeObjectURL(url);
                a.remove();
            }, 100);
        }
        
        // ===== WITHDRAWALS =====
        
        // Fetch withdrawals from Lighter API
        async function fetchWithdrawalsFromLighter(authToken, accountIndex) {
            const allWithdrawals = [];
            let cursor = null;
            let page = 0;
            
            while (true) {
                page++;
                const params = new URLSearchParams({
                    account_index: accountIndex
                });
                if (cursor) {
                    params.append('cursor', cursor);
                }
                
                showStatus('fetchStatus', `Account #${accountIndex}: Fetching withdrawals page ${page}...`, 'loading');
                
                try {
                    const response = await fetch(`${LIGHTER_API}/api/v1/withdraw/history?${params}`, {
                        headers: { 'Authorization': authToken }
                    });
                    
                    if (response.status === 429) {
                        showStatus('fetchStatus', `Rate limited, waiting 15s...`, 'loading');
                        await new Promise(r => setTimeout(r, 15000));
                        continue;
                    }
                    
                    if (!response.ok) {
                        console.error(`HTTP error: ${response.status}`);
                        break;
                    }
                    
                    const data = await response.json();
                    if (data.code !== 200) {
                        console.error(`API error: ${data.code}`);
                        break;
                    }
                    
                    const withdrawals = data.withdraws || [];
                    allWithdrawals.push(...withdrawals);
                    
                    if (!data.cursor || withdrawals.length === 0) {
                        break;
                    }
                    
                    cursor = data.cursor;
                    await new Promise(r => setTimeout(r, WALLET_RATE_LIMIT_DELAY));
                    
                } catch (error) {
                    console.error(`Error fetching withdrawals: ${error}`);
                    break;
                }
            }
            
            return allWithdrawals;
        }
        
        // Fetch withdrawals for all selected accounts
        async function fetchWithdrawals() {
            if (!readOnlyToken) {
                showStatus('fetchStatus', 'Please enter a read-only token first', 'error');
                return;
            }
            
            const selectedAccounts = getSelectedAccounts();
            if (selectedAccounts.length === 0) {
                showStatus('fetchStatus', 'Please select at least one account', 'error');
                return;
            }
            
            const btn = document.getElementById('fetchWithdrawalsBtn');
            setAllFetchButtonsDisabled(true);
            btn.innerHTML = '<span class="spinner"></span>Fetching...';
            
            try {
                // Fetch asset details first
                await fetchAssetDetails();
                
                withdrawalsData = {};
                rawWithdrawalsData = {};
                
                for (const accountIndex of selectedAccounts) {
                    const rawWithdrawals = await fetchWithdrawalsFromLighter(readOnlyToken, accountIndex);
                    rawWithdrawalsData[accountIndex] = rawWithdrawals;
                    
                    // Process withdrawals
                    const processed = processWithdrawals(rawWithdrawals);
                    withdrawalsData[accountIndex] = {
                        success: true,
                        total_withdrawals: processed.length,
                        withdrawals: processed
                    };
                }
                
                let totalWithdrawals = 0;
                Object.values(withdrawalsData).forEach(acc => {
                    totalWithdrawals += acc.total_withdrawals || 0;
                });
                
                showStatus('fetchStatus', `Successfully fetched ${totalWithdrawals} withdrawals`, 'success');
                displayWithdrawalsResults();
                document.getElementById('withdrawalsCard').classList.remove('hidden');
                
            } catch (error) {
                showStatus('fetchStatus', `Error: ${error.message}`, 'error');
            } finally {
                setAllFetchButtonsDisabled(false);
                btn.textContent = 'Fetch Withdrawals';
            }
        }
        
        // Process withdrawals data
        function processWithdrawals(rawWithdrawals) {
            return rawWithdrawals.map(w => {
                const timestamp = w.timestamp;
                const dt = new Date(timestamp);
                const dateStr = dt.toISOString().replace('T', ' ').slice(0, 19) + ' UTC';
                
                return {
                    id: w.id,
                    asset: getAssetSymbol(w.asset_id),
                    amount: w.amount,
                    datetime_utc: dateStr,
                    l1_tx_hash: w.l1_tx_hash
                };
            });
        }
        
        // Display withdrawals results
        function displayWithdrawalsResults() {
            const tabsContainer = document.getElementById('withdrawalsTabs');
            const contentsContainer = document.getElementById('withdrawalsContents');
            tabsContainer.innerHTML = '';
            contentsContainer.innerHTML = '';
            
            const accountIds = Object.keys(withdrawalsData);
            
            accountIds.forEach((accountIndex, i) => {
                const accountData = withdrawalsData[accountIndex];
                const isFirst = i === 0;
                
                // Create tab
                const tab = document.createElement('div');
                tab.className = `tab ${isFirst ? 'active' : ''}`;
                tab.textContent = `Account #${accountIndex}`;
                tab.onclick = () => switchWithdrawalsTab(accountIndex);
                tab.id = `withdrawals-tab-${accountIndex}`;
                tabsContainer.appendChild(tab);
                
                // Create content
                const content = document.createElement('div');
                content.className = `tab-content ${isFirst ? 'active' : ''}`;
                content.id = `withdrawals-content-${accountIndex}`;
                
                if (!accountData.success || accountData.withdrawals.length === 0) {
                    content.innerHTML = `<div class="error-message">No withdrawals found</div>`;
                } else {
                    const safeAccountIndex = parseInt(accountIndex, 10);
                    const safeTotal = parseInt(accountData.total_withdrawals, 10) || 0;
                    content.innerHTML = `
                        <div class="results-header">
                            <span class="results-stats">${safeTotal} withdrawals</span>
                            <div style="display: flex; gap: 8px;">
                                <button class="btn-secondary btn-small" onclick="exportWithdrawalsCSV(${safeAccountIndex})">
                                    CSV
                                </button>
                                <button class="btn-secondary btn-small" onclick="exportWithdrawalsJSON(${safeAccountIndex})">
                                    JSON
                                </button>
                            </div>
                        </div>
                        <div class="results-box">
                            ${buildWithdrawalsTable(accountData.withdrawals)}
                        </div>
                    `;
                }
                
                contentsContainer.appendChild(content);
            });
        }
        
        // Build withdrawals table
        function buildWithdrawalsTable(withdrawals) {
            let html = '<table class="trades-table"><thead><tr>';
            html += `<th>ID</th><th>Asset</th><th>Amount</th><th>Time (UTC)</th>
                <th><span class="header-with-info">Transaction Hash
                    <span class="info-icon">i<span class="info-tooltip">These transactions can be processed on both Ethereum and Arbitrum. If the ID starts with "fast", that means the withdraw was processed to Arbitrum</span></span>
                </span></th>`;
            html += '</tr></thead><tbody>';
            
            withdrawals.forEach(w => {
                const hash = w.l1_tx_hash || '';
                const shortHash = hash ? hash.substring(0, 16) + '...' : 'N/A';
                html += `<tr>
                    <td>${escapeHtml(w.id)}</td>
                    <td><span class="trade-market">${escapeHtml(w.asset)}</span></td>
                    <td>${escapeHtml(w.amount)}</td>
                    <td>${escapeHtml(w.datetime_utc)}</td>
                    <td>${hash ? `<span class="copyable" data-copy="${escapeHtml(hash)}" onclick="copyToClipboard(this)" title="Click to copy">
                        <span class="tx-hash">${escapeHtml(shortHash)}</span>${COPY_ICON_SVG}
                    </span>` : '<span class="tx-hash">N/A</span>'}</td>
                </tr>`;
            });
            
            html += '</tbody></table>';
            return html;
        }
        
        // Switch withdrawals tab
        function switchWithdrawalsTab(accountIndex) {
            document.querySelectorAll('#withdrawalsTabs .tab').forEach(t => t.classList.remove('active'));
            document.getElementById(`withdrawals-tab-${accountIndex}`).classList.add('active');
            
            document.querySelectorAll('#withdrawalsContents .tab-content').forEach(c => c.classList.remove('active'));
            document.getElementById(`withdrawals-content-${accountIndex}`).classList.add('active');
        }
        
        // Export withdrawals as CSV
        function exportWithdrawalsCSV(accountIndex) {
            const data = withdrawalsData[accountIndex];
            if (!data || !data.withdrawals || data.withdrawals.length === 0) {
                alert('No withdrawals to export');
                return;
            }
            
            const headers = ['ID', 'Asset', 'Amount', 'Time (UTC)', 'Transaction Hash'];
            const csvRows = [headers.join(',')];
            
            data.withdrawals.forEach(w => {
                csvRows.push([
                    csvEscape(w.id),
                    csvEscape(w.asset),
                    csvEscape(w.amount),
                    csvEscape(w.datetime_utc),
                    csvEscape(w.l1_tx_hash)
                ].join(','));
            });
            
            const csvContent = csvRows.join('\n');
            const now = new Date();
            const timestamp = now.toISOString().replace(/[:.]/g, '-').slice(0, 19);
            const filename = `lighter_withdrawals_account_${accountIndex}_${timestamp}.csv`;
            
            const BOM = '\uFEFF';
            const encodedContent = encodeURIComponent(BOM + csvContent);
            const dataUri = `data:text/csv;charset=utf-8,${encodedContent}`;
            
            const a = document.createElement('a');
            a.href = dataUri;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            a.remove();
        }
        
        // Export withdrawals as JSON
        function exportWithdrawalsJSON(accountIndex) {
            const rawWithdrawals = rawWithdrawalsData[accountIndex];
            if (!rawWithdrawals || rawWithdrawals.length === 0) {
                alert('No withdrawals to export');
                return;
            }
            
            const jsonContent = JSON.stringify({
                exported_at: new Date().toISOString(),
                account_index: parseInt(accountIndex),
                total_withdrawals: rawWithdrawals.length,
                withdrawals: rawWithdrawals
            }, null, 2);
            
            const now = new Date();
            const timestamp = now.toISOString().replace(/[:.]/g, '-').slice(0, 19);
            const filename = `lighter_withdrawals_account_${accountIndex}_${timestamp}.json`;
            
            const blob = new Blob([jsonContent], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            
            setTimeout(() => {
                URL.revokeObjectURL(url);
                a.remove();
            }, 100);
        }
        
        // Initialize on page load
        initColumnSelection();
    </script>
</body>
</html>
