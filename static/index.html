<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lighter Trades Fetcher</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&family=Outfit:wght@300;400;500;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-primary: #0a0a0f;
            --bg-secondary: #12121a;
            --bg-tertiary: #1a1a25;
            --text-primary: #f0f0f5;
            --text-secondary: #9090a0;
            --text-muted: #606070;
            --border: #2a2a35;
            --accent: #4a6a9a;
            --accent-dim: #3d577a;
            --accent-alt: #5aad69;
            --error: #ef4444;
            --success: #5aad69;
            --warning: #f59e0b;
            --bid-color: #4a7c59;
            --ask-color: #8a5a5a;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'JetBrains Mono', monospace;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            line-height: 1.6;
        }

        /* Background gradient blurs */
        .bg-gradients {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: -1;
            overflow: hidden;
        }

        .bg-gradients::before {
            content: '';
            position: absolute;
            top: -10%;
            left: 15%;
            width: 400px;
            height: 400px;
            background: rgba(74, 106, 154, 0.03);
            border-radius: 50%;
            filter: blur(80px);
        }

        .bg-gradients::after {
            content: '';
            position: absolute;
            top: 30%;
            right: 10%;
            width: 350px;
            height: 350px;
            background: rgba(90, 173, 105, 0.02);
            border-radius: 50%;
            filter: blur(80px);
        }

        /* Glass panel design */
        .glass-panel {
            background: linear-gradient(
                135deg,
                rgba(26, 26, 37, 0.95) 0%,
                rgba(18, 18, 26, 0.98) 100%
            );
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid var(--border);
            border-radius: 4px;
        }

        .glow-accent {
            box-shadow: 0 0 12px rgba(74, 106, 154, 0.08);
        }

        .glow-success {
            box-shadow: 0 0 12px rgba(90, 173, 105, 0.08);
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 32px 16px;
            position: relative;
            z-index: 10;
        }

        header {
            margin-bottom: 32px;
        }

        h1 {
            font-size: 1.3rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 6px;
            letter-spacing: 0.08em;
            font-family: 'JetBrains Mono', monospace;
            text-transform: uppercase;
        }

        h1 span {
            color: var(--text-primary);
        }

        .subtitle {
            color: var(--text-muted);
            font-size: 0.85rem;
            font-weight: 400;
        }

        .card {
            background: linear-gradient(
                135deg,
                rgba(26, 26, 37, 0.95) 0%,
                rgba(18, 18, 26, 0.98) 100%
            );
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 24px;
            margin-bottom: 16px;
        }

        .card-title {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 16px;
            text-transform: uppercase;
            letter-spacing: 0.08em;
        }

        .card-title.collapsible {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            user-select: none;
            padding: 10px 14px;
            margin: -12px -14px 16px -14px;
            border-radius: 4px;
            transition: background 0.2s;
        }

        .card-title.collapsible:hover {
            background: rgba(255, 255, 255, 0.02);
        }

        .card-title .collapse-icon {
            font-size: 0.7rem;
            color: var(--text-muted);
            transition: transform 0.3s ease;
        }

        .card-title.collapsed .collapse-icon {
            transform: rotate(-90deg);
        }

        .card-content {
            transition: max-height 0.3s ease, opacity 0.2s ease;
            overflow: hidden;
        }

        .card-content.collapsed {
            max-height: 0 !important;
            opacity: 0;
            margin: 0;
            padding: 0;
        }

        .form-group {
            margin-bottom: 16px;
        }

        label {
            display: block;
            font-size: 0.75rem;
            font-weight: 500;
            color: var(--text-muted);
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.06em;
        }

        input {
            width: 100%;
            padding: 12px 14px;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            transition: border-color 0.2s;
        }

        input:focus {
            outline: none;
            border-color: var(--accent);
        }

        input::placeholder {
            color: var(--text-muted);
        }

        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }

        @media (max-width: 600px) {
            .form-row {
                grid-template-columns: 1fr;
            }
        }

        button {
            padding: 10px 18px;
            border: 1px solid var(--border);
            border-radius: 4px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            background: var(--bg-secondary);
            color: var(--text-primary);
        }

        button:hover:not(:disabled) {
            border-color: var(--text-muted);
        }

        .btn-primary {
            background: rgba(74, 106, 154, 0.15);
            color: var(--accent);
            border-color: rgba(74, 106, 154, 0.4);
        }

        .btn-primary:hover:not(:disabled) {
            background: rgba(74, 106, 154, 0.25);
            border-color: var(--accent);
        }

        .btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            border: 1px solid var(--border);
        }

        .btn-secondary:hover:not(:disabled) {
            border-color: var(--text-muted);
        }

        .btn-small {
            padding: 6px 12px;
            font-size: 0.75rem;
        }

        button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .btn-group {
            display: flex;
            gap: 8px;
            margin-top: 16px;
            flex-wrap: wrap;
        }

        .status {
            margin-top: 16px;
            padding: 12px 14px;
            border-radius: 4px;
            font-size: 0.8rem;
            display: none;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status.show {
            display: flex;
        }

        .status::before {
            content: '';
            width: 8px;
            height: 8px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .status.loading {
            background: rgba(74, 106, 154, 0.1);
            border: 1px solid rgba(74, 106, 154, 0.3);
            color: var(--accent);
        }

        .status.loading::before {
            background: var(--accent);
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        .status.error {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.3);
            color: var(--error);
        }

        .status.error::before {
            background: var(--error);
        }

        .status.success {
            background: rgba(90, 173, 105, 0.1);
            border: 1px solid rgba(90, 173, 105, 0.3);
            color: var(--success);
        }

        .status.success::before {
            background: var(--success);
            box-shadow: 0 0 6px rgba(90, 173, 105, 0.4);
        }

        /* Account selection */
        .accounts-list {
            margin-top: 12px;
        }

        .account-item {
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 14px;
            margin-bottom: 10px;
        }

        .account-item.selected {
            border-color: rgba(74, 106, 154, 0.5);
            background: rgba(74, 106, 154, 0.05);
        }

        .account-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .account-header input[type="checkbox"] {
            width: 16px;
            height: 16px;
            accent-color: var(--accent);
        }

        .account-header label {
            margin-bottom: 0;
            font-size: 0.85rem;
            color: var(--text-primary);
            text-transform: none;
            letter-spacing: normal;
        }

        .account-fields {
            display: none;
            padding-top: 10px;
            border-top: 1px solid var(--border);
        }

        .account-item.selected .account-fields {
            display: block;
        }

        /* Column selector */
        .column-selector {
            margin-bottom: 12px;
            padding: 10px 12px;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 4px;
        }

        .column-selector-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            color: var(--text-muted);
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .column-selector-header:hover {
            color: var(--text-secondary);
        }

        .column-options {
            display: none;
            margin-top: 10px;
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .column-selector.expanded .column-options {
            display: flex;
        }

        .column-option {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 5px 10px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 4px;
            font-size: 0.7rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .column-option:hover {
            border-color: var(--text-muted);
        }

        .column-option.active {
            border-color: rgba(74, 106, 154, 0.5);
            background: rgba(74, 106, 154, 0.1);
        }

        .column-option input {
            width: 12px;
            height: 12px;
            accent-color: var(--accent);
        }

        /* Timeframe Selector */
        .timeframe-selector {
            margin-bottom: 16px;
            padding: 14px;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 4px;
        }

        .timeframe-selector-title {
            font-size: 0.7rem;
            font-weight: 500;
            color: var(--text-muted);
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.06em;
        }

        .timeframe-options {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
            flex-wrap: wrap;
        }

        .timeframe-option {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 12px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .timeframe-option:hover {
            border-color: var(--text-muted);
        }

        .timeframe-option.active {
            border-color: rgba(74, 106, 154, 0.5);
            background: rgba(74, 106, 154, 0.1);
        }

        .timeframe-option input[type="radio"] {
            width: 14px;
            height: 14px;
            accent-color: var(--accent);
        }

        .timeframe-option label {
            margin: 0;
            text-transform: none;
            letter-spacing: normal;
            font-size: 0.8rem;
            color: var(--text-secondary);
            cursor: pointer;
        }

        .timeframe-info-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 14px;
            height: 14px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 50%;
            font-size: 9px;
            color: var(--text-muted);
            cursor: help;
            position: relative;
        }

        .timeframe-info-icon:hover .timeframe-tooltip {
            opacity: 1;
            visibility: visible;
        }

        .timeframe-tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 6px 10px;
            font-size: 0.7rem;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s;
            z-index: 100;
            margin-bottom: 6px;
            color: var(--text-secondary);
        }

        .date-range-inputs {
            display: none;
            gap: 10px;
            margin-top: 12px;
        }

        .date-range-inputs.visible {
            display: flex;
            flex-wrap: wrap;
        }

        .date-input-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .date-input-group label {
            font-size: 0.7rem;
            color: var(--text-muted);
        }

        .date-input-group input[type="datetime-local"],
        .date-input-group input[type="date"],
        .date-input-group input[type="time"] {
            padding: 8px 10px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            min-width: 140px;
        }

        .date-input-group input[type="datetime-local"]:focus,
        .date-input-group input[type="date"]:focus,
        .date-input-group input[type="time"]:focus {
            outline: none;
            border-color: var(--accent);
        }

        .date-input-group input[type="datetime-local"]::-webkit-calendar-picker-indicator,
        .date-input-group input[type="date"]::-webkit-calendar-picker-indicator,
        .date-input-group input[type="time"]::-webkit-calendar-picker-indicator {
            filter: invert(0.6);
            cursor: pointer;
        }

        .hours-toggle {
            display: flex;
            align-items: center;
        }

        .hours-toggle .checkbox-label {
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
            font-size: 0.75rem;
            color: var(--text-muted);
            text-transform: none;
            letter-spacing: normal;
        }

        .hours-toggle input[type="checkbox"] {
            width: 14px;
            height: 14px;
            accent-color: var(--accent);
            cursor: pointer;
        }

        .time-range-inputs {
            display: none;
            gap: 10px;
            margin-top: 10px;
        }

        .time-range-inputs.visible {
            display: flex;
            flex-wrap: wrap;
        }

        /* Tabs */
        .tabs {
            display: flex;
            gap: 2px;
            margin-bottom: 12px;
            flex-wrap: wrap;
            background: var(--bg-secondary);
            padding: 3px;
            border-radius: 4px;
            width: fit-content;
        }

        .tab {
            padding: 8px 16px;
            background: transparent;
            border: none;
            border-radius: 3px;
            color: var(--text-muted);
            cursor: pointer;
            font-size: 0.75rem;
            font-weight: 500;
            transition: all 0.2s;
        }

        .tab:hover {
            color: var(--text-secondary);
        }

        .tab.active {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .results-header h2 {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .results-stats {
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        .results-box {
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 0;
            max-height: 450px;
            overflow-y: auto;
            overflow-x: auto;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            line-height: 1.5;
        }

        .trades-table {
            width: 100%;
            border-collapse: collapse;
            min-width: 800px;
        }

        .trades-table th {
            text-align: left;
            padding: 10px 12px;
            background: var(--bg-secondary);
            color: var(--text-muted);
            font-weight: 500;
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 0.06em;
            border-bottom: 1px solid var(--border);
            position: sticky;
            top: 0;
            z-index: 10;
            overflow: visible;
        }

        .trades-table th:has(.info-icon:hover) {
            z-index: 1002;
            overflow: visible;
        }

        .trades-table thead {
            overflow: visible;
        }

        .trades-table td {
            padding: 8px 12px;
            border-bottom: 1px solid rgba(42, 42, 53, 0.5);
            white-space: nowrap;
            color: var(--text-secondary);
        }

        .trades-table tr:hover td {
            background: rgba(255, 255, 255, 0.02);
        }

        .trade-market {
            color: var(--text-primary);
            font-weight: 500;
        }

        .trade-side.long {
            color: var(--bid-color);
        }

        .trade-side.short {
            color: var(--ask-color);
        }

        .market-type {
            font-weight: 500;
            font-size: 0.65rem;
            padding: 2px 6px;
            border-radius: 3px;
        }

        .market-type.type-perp {
            color: #9a7aa5;
            background: rgba(154, 122, 165, 0.15);
        }

        .market-type.type-spot {
            color: #5aa5d4;
            background: rgba(90, 165, 212, 0.15);
        }

        .trade-pnl.profit {
            color: var(--success);
        }

        .trade-pnl.loss {
            color: var(--error);
        }

        .tx-hash {
            font-size: 0.65rem;
            color: var(--text-muted);
            max-width: 100px;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Copyable field styles */
        .copyable {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            cursor: pointer;
            position: relative;
            z-index: 1;
        }

        .copyable:hover {
            color: var(--text-primary);
        }

        .copy-icon {
            width: 12px;
            height: 12px;
            opacity: 0.4;
            transition: opacity 0.2s;
        }

        .copyable:hover .copy-icon {
            opacity: 0.8;
        }

        .copy-success {
            color: var(--success) !important;
        }

        /* Info icon and tooltip styles */
        .header-with-info {
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }

        .info-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--border);
            color: var(--text-muted);
            font-size: 0.55rem;
            font-weight: 600;
            cursor: help;
            position: relative;
            z-index: 1;
        }

        .info-icon:hover {
            background: var(--text-muted);
            color: var(--bg-primary);
            z-index: 1001;
        }

        .info-tooltip {
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 8px 10px;
            font-size: 0.7rem;
            font-weight: 400;
            text-transform: none;
            letter-spacing: normal;
            white-space: normal;
            width: 220px;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s, visibility 0.2s;
            margin-top: 4px;
            line-height: 1.4;
            color: var(--text-muted);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        }

        .info-tooltip a {
            color: var(--accent);
            text-decoration: none;
        }

        .info-tooltip a:hover {
            text-decoration: underline;
        }

        .info-icon:hover .info-tooltip {
            opacity: 1;
            visibility: visible;
        }

        .info-tooltip::before {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-bottom-color: var(--border);
        }

        .security-note {
            margin-top: 20px;
            padding: 12px 14px;
            background: rgba(74, 106, 154, 0.05);
            border: 1px solid rgba(74, 106, 154, 0.2);
            border-radius: 4px;
            font-size: 0.75rem;
            color: var(--text-muted);
            line-height: 1.5;
        }

        .security-note strong {
            color: var(--text-secondary);
            font-weight: 500;
        }

        .spinner {
            display: inline-block;
            width: 12px;
            height: 12px;
            border: 2px solid transparent;
            border-top-color: currentColor;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin-right: 6px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Global scrollbar styling */
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }

        /* Selection */
        ::selection {
            background: var(--accent);
            color: var(--text-primary);
        }

        .hidden {
            display: none !important;
        }

        .error-message {
            color: var(--error);
            padding: 16px;
            text-align: center;
            font-size: 0.85rem;
        }

        /* FAQ Styles */
        .faq-section {
            margin-bottom: 20px;
        }

        .faq-container {
            background: linear-gradient(
                135deg,
                rgba(26, 26, 37, 0.95) 0%,
                rgba(18, 18, 26, 0.98) 100%
            );
            border: 1px solid var(--border);
            border-radius: 4px;
            overflow: hidden;
        }

        .faq-main-toggle {
            padding: 14px 16px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 500;
            font-size: 0.85rem;
            color: var(--text-secondary);
            transition: background 0.2s;
        }

        .faq-main-toggle:hover {
            background: rgba(255, 255, 255, 0.02);
        }

        .faq-items {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.4s ease-out;
        }

        .faq-items.open {
            max-height: 1000px;
        }

        .faq-item {
            background: var(--bg-primary);
            margin: 0 10px 6px 10px;
            border-radius: 4px;
            border: 1px solid var(--border);
            overflow: hidden;
        }

        .faq-item:first-child {
            margin-top: 6px;
        }

        .faq-item:last-child {
            margin-bottom: 10px;
        }

        .faq-question {
            padding: 12px 14px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 500;
            font-size: 0.8rem;
            color: var(--text-secondary);
            transition: background 0.2s;
        }

        .faq-question:hover {
            background: rgba(255,255,255,0.02);
            color: var(--text-primary);
        }

        .faq-toggle {
            color: var(--text-muted);
            font-size: 1rem;
            transition: transform 0.3s;
        }

        .faq-container.open > .faq-main-toggle .faq-toggle {
            transform: rotate(45deg);
        }

        .faq-item.open .faq-toggle {
            transform: rotate(45deg);
            color: var(--accent);
        }

        .faq-answer {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }

        .faq-item.open .faq-answer {
            max-height: 500px;
        }

        .faq-answer-content {
            padding: 0 14px 12px 14px;
            color: var(--text-muted);
            font-size: 0.75rem;
            line-height: 1.6;
        }

        .faq-answer-content a {
            color: var(--text-secondary);
            text-decoration: none;
        }

        .faq-answer-content a:hover {
            color: var(--text-primary);
        }

        /* Footer */
        .footer {
            text-align: center;
            padding: 20px;
            color: var(--text-muted);
            font-size: 0.75rem;
            margin-top: 24px;
        }

        .footer a {
            color: var(--text-secondary);
            text-decoration: none;
            font-weight: 500;
            transition: color 0.2s;
        }

        .footer a:hover {
            color: var(--text-primary);
        }
    </style>
</head>
<body>
    <div class="bg-gradients"></div>
    <div class="container">
        <header>
            <h1><span>LIGHTER</span> EXPORT TRADING DATA</h1>
            <p class="subtitle">Fetch trades, funding, deposits, transfers, and withdrawals</p>
        </header>

        <!-- FAQ Section -->
        <div class="faq-section">
            <div class="faq-container">
                <div class="faq-main-toggle" onclick="toggleFaqSection()">
                    <span>Frequently Asked Questions</span>
                    <span class="faq-toggle" id="faqMainToggle">+</span>
                </div>
                <div class="faq-items" id="faqItems">
                    <div class="faq-item">
                        <div class="faq-question" onclick="toggleFaq(this)">
                            <span>What is a read-only auth token?</span>
                            <span class="faq-toggle">+</span>
                        </div>
                        <div class="faq-answer">
                            <div class="faq-answer-content">
                                A read-only auth token (starting with "ro:") can only be used to fetch data — it cannot trade or withdraw funds. 
                                This is the safest option for exporting your trading history. Generate one at 
                                <a href="https://app.lighter.xyz/read-only-tokens" target="_blank">app.lighter.xyz/read-only-tokens</a>.
                            </div>
                        </div>
                    </div>
                    
                    <div class="faq-item">
                        <div class="faq-question" onclick="toggleFaq(this)">
                            <span>Why do I only need one token for all accounts?</span>
                            <span class="faq-toggle">+</span>
                        </div>
                        <div class="faq-answer">
                            <div class="faq-answer-content">
                                Read-only tokens are scoped to your L1 address, so a single token can access data from all sub-accounts 
                                associated with that address. This makes it easier to export data from multiple accounts at once. Make sure to click on "Allow Sub-account Access" when you generate the token.
                            </div>
                        </div>
                    </div>
                    
                    <div class="faq-item">
                        <div class="faq-question" onclick="toggleFaq(this)">
                            <span>How long will it take to fetch all my trades and funding payments?</span>
                            <span class="faq-toggle">+</span>
                        </div>
                        <div class="faq-answer">
                            <div class="faq-answer-content">
                                To avoid rate limits on the platform, we fetch ~1.7K trades per minute and ~3.6K funding payments per minute. 
                                You should close the Lighter front-end while using this app or you risk getting rate limited. 
                            </div>
                        </div>
                    </div>
                    
                    <div class="faq-item">
                        <div class="faq-question" onclick="toggleFaq(this)">
                            <span>How can I export the data fetched?</span>
                            <span class="faq-toggle">+</span>
                        </div>
                        <div class="faq-answer">
                            <div class="faq-answer-content">
                                You will see the output here in the app, with the option to also download it in a CSV file, or a JSON file 
                                (this will be the raw JSON we fetched from the Lighter servers). Furthermore, you can customize the fields to see and export.
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Step 1: Lookup Accounts -->
        <div class="card" id="step1Card">
            <div class="card-title collapsible" onclick="toggleCardCollapse('step1Card')">
                <span>Step 1: Lookup Accounts</span>
                <span class="collapse-icon">▼</span>
            </div>
            <div class="card-content" id="step1CardContent">
                <div class="form-group">
                    <label for="l1Address">L1 Address</label>
                    <input 
                        type="text" 
                        id="l1Address" 
                        placeholder="0x..."
                        required
                    >
                </div>
                <button class="btn-primary" id="lookupBtn" onclick="lookupAccounts()">
                    Lookup Accounts
                </button>
                <div id="lookupStatus" class="status"></div>
            </div>
        </div>

        <!-- Step 2: Enter Read-Only Token -->
        <div class="card hidden" id="step2Card">
            <div class="card-title collapsible" onclick="toggleCardCollapse('step2Card')">
                <span>Step 2: Enter Read-Only Token</span>
                <span class="collapse-icon">▼</span>
            </div>
            <div class="card-content" id="step2CardContent">
                <p style="color: var(--text-muted); margin-bottom: 14px; font-size: 0.8rem; line-height: 1.5;">
                    Enter your read-only auth token. This single token will be used to fetch data from all selected accounts.
                    <br><br>
                    Generate a read-only token at <a href="https://app.lighter.xyz/read-only-tokens" target="_blank" style="color: var(--text-secondary);">app.lighter.xyz/read-only-tokens</a>
                </p>
                <div class="form-group">
                    <label for="readOnlyToken">Read-Only Auth Token</label>
                    <input 
                        type="password" 
                        id="readOnlyToken" 
                        placeholder="ro:60973:all:1765479143:90d64052f462..."
                        required
                    >
                </div>
                <button class="btn-primary" id="continueBtn" onclick="continueToAccountSelection()">
                    Continue
                </button>
                <div id="tokenStatus" class="status"></div>
            </div>
        </div>

        <!-- Step 3: Select Accounts -->
        <div class="card hidden" id="step3Card">
            <div class="card-title collapsible" onclick="toggleCardCollapse('step3Card')">
                <span>Step 3: Select Accounts & Fetch</span>
                <span class="collapse-icon">▼</span>
            </div>
            <div class="card-content" id="step3CardContent">
                <p style="color: var(--text-muted); margin-bottom: 12px; font-size: 0.8rem;">
                    Select the accounts you want to fetch data from.
                </p>
                <div id="accountsList" class="accounts-list"></div>
                
                <!-- Timeframe Selector -->
                <div class="timeframe-selector">
                    <div class="timeframe-selector-title">Timeframe</div>
                    <div class="timeframe-options">
                        <div class="timeframe-option active" onclick="selectTimeframe('complete')">
                            <input type="radio" name="timeframe" id="timeframeComplete" value="complete" checked>
                            <label for="timeframeComplete">Complete account history</label>
                            <span class="timeframe-info-icon">i
                                <span class="timeframe-tooltip">Fetches all data from account creation to present</span>
                            </span>
                        </div>
                        <div class="timeframe-option" onclick="selectTimeframe('custom')">
                            <input type="radio" name="timeframe" id="timeframeCustom" value="custom">
                            <label for="timeframeCustom">Custom timeframe</label>
                            <span class="timeframe-info-icon">i
                                <span class="timeframe-tooltip">Select specific start and end dates</span>
                            </span>
                        </div>
                    </div>
                    <div class="date-range-inputs" id="dateRangeInputs">
                        <div class="date-input-group">
                            <label for="dateFrom">From (Start)</label>
                            <input type="date" id="dateFrom">
                        </div>
                        <div class="date-input-group">
                            <label for="dateTo">To (End)</label>
                            <input type="date" id="dateTo">
                        </div>
                        <div class="date-input-group hours-toggle">
                            <label class="checkbox-label" onclick="toggleHoursSelection()">
                                <input type="checkbox" id="includeHours">
                                <span>Include specific hours</span>
                            </label>
                        </div>
                    </div>
                    <div class="time-range-inputs" id="timeRangeInputs">
                        <div class="date-input-group">
                            <label for="timeFrom">Start Time</label>
                            <input type="time" id="timeFrom" value="00:00">
                        </div>
                        <div class="date-input-group">
                            <label for="timeTo">End Time</label>
                            <input type="time" id="timeTo" value="23:59">
                        </div>
                    </div>
                </div>
                
                <div class="btn-group" style="flex-wrap: wrap;">
                    <button class="btn-primary" id="fetchTradesBtn" onclick="fetchTrades()">
                        Fetch Trades
                    </button>
                    <button class="btn-primary" id="fetchFundingBtn" onclick="fetchFunding()">
                        Fetch Funding
                    </button>
                    <button class="btn-primary" id="fetchDepositsBtn" onclick="fetchDeposits()">
                        Fetch Deposits
                    </button>
                    <button class="btn-primary" id="fetchTransfersBtn" onclick="fetchTransfers()">
                        Fetch Transfers
                    </button>
                    <button class="btn-primary" id="fetchWithdrawalsBtn" onclick="fetchWithdrawals()">
                        Fetch Withdrawals
                    </button>
                </div>
                <div id="fetchStatus" class="status"></div>
            </div>
        </div>

        <!-- Step 3: Results -->
        <div class="card hidden" id="resultsCard">
            <div class="card-title collapsible" onclick="toggleCardCollapse('resultsCard')">
                <span>Trade History</span>
                <span class="collapse-icon">▼</span>
            </div>
            <div class="card-content" id="resultsCardContent">
                <!-- Column Selector -->
                <div class="column-selector expanded" id="columnSelector">
                    <div class="column-selector-header" onclick="toggleColumnSelector()">
                        <span>Select Columns to Display/Export</span>
                        <span id="toggleIcon">▼</span>
                    </div>
                    <div class="column-options" id="columnOptions"></div>
                </div>
                
                <!-- Market Type Filter -->
                <div class="type-filter" id="marketTypeFilter" style="margin-bottom: 12px; padding: 10px 12px; background: var(--bg-primary); border: 1px solid var(--border); border-radius: 4px;">
                    <div style="color: var(--text-muted); font-size: 0.7rem; margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.05em;">Filter by Market Type:</div>
                    <div style="display: flex; flex-wrap: wrap; gap: 6px;">
                        <label class="column-option active" onclick="toggleMarketType('Perp')">
                            <input type="checkbox" checked onchange="toggleMarketType('Perp')" onclick="event.stopPropagation()">
                            Perpetuals
                        </label>
                        <label class="column-option active" onclick="toggleMarketType('Spot')">
                            <input type="checkbox" checked onchange="toggleMarketType('Spot')" onclick="event.stopPropagation()">
                            Spot
                        </label>
                    </div>
                </div>
                
                <div id="accountTabs" class="tabs"></div>
                <div id="accountContents"></div>
            </div>
        </div>

        <!-- Funding Payments Results -->
        <div class="card hidden" id="fundingCard">
            <div class="card-title collapsible" onclick="toggleCardCollapse('fundingCard')">
                <span>Funding Payments</span>
                <span class="collapse-icon">▼</span>
            </div>
            <div class="card-content" id="fundingCardContent">
                <div id="fundingTabs" class="tabs"></div>
                <div id="fundingContents"></div>
            </div>
        </div>

        <!-- Deposits Results -->
        <div class="card hidden" id="depositsCard">
            <div class="card-title collapsible" onclick="toggleCardCollapse('depositsCard')">
                <span>Deposits</span>
                <span class="collapse-icon">▼</span>
            </div>
            <div class="card-content" id="depositsCardContent">
                <div id="depositsTabs" class="tabs"></div>
                <div id="depositsContents"></div>
            </div>
        </div>

        <!-- Transfers Results -->
        <div class="card hidden" id="transfersCard">
            <div class="card-title collapsible" onclick="toggleCardCollapse('transfersCard')">
                <span>Transfers</span>
                <span class="collapse-icon">▼</span>
            </div>
            <div class="card-content" id="transfersCardContent">
                <!-- Type Filter -->
                <div class="type-filter" id="transferTypeFilter" style="margin-bottom: 16px; padding: 12px; background: var(--bg-tertiary); border-radius: 8px;">
                    <div style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 8px;">Filter by Type:</div>
                    <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                        <label class="column-option active" onclick="toggleTransferType('L2TransferOutflow')">
                            <input type="checkbox" checked onchange="toggleTransferType('L2TransferOutflow')" onclick="event.stopPropagation()">
                            Outgoing Transfer
                        </label>
                        <label class="column-option active" onclick="toggleTransferType('L2TransferInflow')">
                            <input type="checkbox" checked onchange="toggleTransferType('L2TransferInflow')" onclick="event.stopPropagation()">
                            Incoming Transfer
                        </label>
                        <label class="column-option active" onclick="toggleTransferType('L2SelfTransfer')">
                            <input type="checkbox" checked onchange="toggleTransferType('L2SelfTransfer')" onclick="event.stopPropagation()">
                            Internal Transfer
                        </label>
                        <label class="column-option active" onclick="toggleTransferType('L2MintSharesOutflow')">
                            <input type="checkbox" checked onchange="toggleTransferType('L2MintSharesOutflow')" onclick="event.stopPropagation()">
                            Public Pool Mint
                        </label>
                        <label class="column-option active" onclick="toggleTransferType('L2BurnSharesInflow')">
                            <input type="checkbox" checked onchange="toggleTransferType('L2BurnSharesInflow')" onclick="event.stopPropagation()">
                            Public Pool Burn
                        </label>
                    </div>
                </div>
                <div id="transfersTabs" class="tabs"></div>
                <div id="transfersContents"></div>
            </div>
        </div>

        <!-- Withdrawals Results -->
        <div class="card hidden" id="withdrawalsCard">
            <div class="card-title collapsible" onclick="toggleCardCollapse('withdrawalsCard')">
                <span>Withdrawals</span>
                <span class="collapse-icon">▼</span>
            </div>
            <div class="card-content" id="withdrawalsCardContent">
                <div id="withdrawalsTabs" class="tabs"></div>
                <div id="withdrawalsContents"></div>
            </div>
        </div>

        <div class="security-note">
            <strong>Security Note:</strong> This app uses read-only auth tokens — they can only view data, not trade or withdraw.
            Trade data is fetched directly from your browser to Lighter's API (rate limits apply to your IP). 
            Tokens are never stored or logged.
            This application is <a href="https://github.com/techcobain/Lighter-export-trades" target="_blank" style="color: var(--accent);">open source</a> 
            so you're free to audit the code, and run it locally if you prefer.
        </div>
        
        <div class="footer">
            Built by <a href="https://t.me/heysupertramp" target="_blank">Supertramp</a>
        </div>
    </div>

    <script>
        // ===== SECURITY: HTML Escaping to prevent XSS =====
        function escapeHtml(unsafe) {
            if (unsafe === null || unsafe === undefined) return '';
            return String(unsafe)
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }
        
        // Copy to clipboard function (uses data-copy attribute for safety)
        function copyToClipboard(element) {
            const text = element.dataset.copy;
            if (!text || text === 'null' || text === 'undefined') {
                return;
            }
            navigator.clipboard.writeText(text).then(() => {
                // Visual feedback
                element.classList.add('copy-success');
                const span = element.querySelector('.tx-hash');
                if (span) {
                    const originalText = span.textContent;
                    span.textContent = 'Copied!';
                    setTimeout(() => {
                        span.textContent = originalText;
                        element.classList.remove('copy-success');
                    }, 1000);
                }
            }).catch(err => {
                console.error('Failed to copy:', err);
            });
        }
        
        // SVG icons
        const COPY_ICON_SVG = `<svg class="copy-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>`;
        
        // CSV escape helper - properly escapes values for CSV format
        function csvEscape(value) {
            if (value === null || value === undefined) return '';
            const str = String(value);
            // Escape double quotes by doubling them, wrap in quotes
            return `"${str.replace(/"/g, '""')}"`;
        }
        
        // FAQ Toggle - Main section
        function toggleFaqSection() {
            const container = document.querySelector('.faq-container');
            const items = document.getElementById('faqItems');
            container.classList.toggle('open');
            items.classList.toggle('open');
        }
        
        // FAQ Toggle - Individual items
        function toggleFaq(element) {
            const faqItem = element.parentElement;
            faqItem.classList.toggle('open');
        }
        
        // State
        let accountIndexes = [];
        let readOnlyToken = null; // Single read-only token for all accounts
        let fetchedData = {}; // { accountIndex: { trades: [...], ... } }
        let rawTradesData = {}; // { accountIndex: [raw trades from API] }
        let fundingData = {}; // { accountIndex: { fundings: [...], ... } }
        let rawFundingData = {}; // { accountIndex: [raw funding from API] }
        let selectedTimeframe = 'complete'; // 'complete' or 'custom'
        let customDateFrom = null; // Timestamp in ms
        let customDateTo = null; // Timestamp in ms
        let depositsData = {}; // { accountIndex: { deposits: [...], ... } }
        let rawDepositsData = {}; // { accountIndex: [raw deposits from API] }
        let transfersData = {}; // { accountIndex: { transfers: [...], ... } }
        let rawTransfersData = {}; // { accountIndex: [raw transfers from API] }
        let withdrawalsData = {}; // { accountIndex: { withdrawals: [...], ... } }
        let rawWithdrawalsData = {}; // { accountIndex: [raw withdrawals from API] }
        
        // Asset cache for mapping asset_id to symbol
        let assetCache = {};
        let assetCacheTimestamp = 0;
        const ASSET_CACHE_TTL = 3600000; // 1 hour in ms
        
        // Transfer type mappings
        const TRANSFER_TYPE_MAP = {
            'L2TransferOutflow': 'Outgoing Transfer',
            'L2BurnSharesInflow': 'Public Pool Burn',
            'L2MintSharesOutflow': 'Public Pool Mint',
            'L2SelfTransfer': 'Internal Transfer',
            'L2TransferInflow': 'Incoming Transfer'
        };
        
        // Transfer type filter state (all enabled by default)
        let transferTypeFilters = {
            'L2TransferOutflow': true,
            'L2BurnSharesInflow': true,
            'L2MintSharesOutflow': true,
            'L2SelfTransfer': true,
            'L2TransferInflow': true
        };
        
        // Market type filter state (all enabled by default)
        let marketTypeFilters = {
            'Perp': true,
            'Spot': true
        };
        
        // Fetch asset details and cache them
        async function fetchAssetDetails() {
            const now = Date.now();
            if (Object.keys(assetCache).length > 0 && (now - assetCacheTimestamp) < ASSET_CACHE_TTL) {
                return assetCache;
            }
            
            try {
                const response = await fetch(`${LIGHTER_API}/api/v1/assetDetails`);
                if (response.ok) {
                    const data = await response.json();
                    if (data.code === 200 && data.asset_details) {
                        assetCache = {};
                        data.asset_details.forEach(asset => {
                            assetCache[asset.asset_id] = {
                                symbol: asset.symbol,
                                name: asset.name || asset.symbol,
                                decimals: asset.decimals || 8
                            };
                        });
                        assetCacheTimestamp = now;
                    } else {
                        console.warn('Asset details API returned unexpected format');
                    }
                } else {
                    console.warn(`Asset details fetch failed with status: ${response.status}`);
                }
            } catch (error) {
                console.error('Error fetching asset details:', error);
                // Show warning to user if this is first fetch (no cache)
                if (Object.keys(assetCache).length === 0) {
                    showStatus('fetchStatus', 'Warning: Could not load asset symbols. Asset IDs will be shown instead.', 'loading');
                    await new Promise(r => setTimeout(r, 2000)); // Show for 2 seconds
                }
            }
            return assetCache;
        }
        
        // Get asset symbol by ID
        function getAssetSymbol(assetId) {
            const asset = assetCache[assetId];
            return asset ? asset.symbol : `Asset #${assetId}`;
        }
        
        // All available columns with display names and default visibility
        const ALL_COLUMNS = {
            trade_id: { label: 'Trade ID', default: false },
            tx_hash: { label: 'Tx Hash', default: false },
            market: { label: 'Market', default: true },
            market_type: { label: 'Type', default: true },
            side: { label: 'Side', default: true },
            datetime_utc: { label: 'Date/Time', default: true },
            trade_value_usd: { label: 'Value ($)', default: true },
            size: { label: 'Size', default: true },
            price_usd: { label: 'Price ($)', default: true },
            fee_usd: { label: 'Fee ($)', default: true },
            role: { label: 'Role', default: true },
            trade_type: { label: 'Type', default: true },
            pnl_usd: { label: 'PnL ($)', default: true }
        };
        
        // Track selected columns
        let selectedColumns = {};
        
        // Initialize selected columns from defaults
        function initColumnSelection() {
            Object.keys(ALL_COLUMNS).forEach(col => {
                selectedColumns[col] = ALL_COLUMNS[col].default;
            });
            renderColumnOptions();
        }
        
        // Render column checkboxes
        function renderColumnOptions() {
            const container = document.getElementById('columnOptions');
            container.innerHTML = Object.entries(ALL_COLUMNS).map(([key, config]) => `
                <label class="column-option ${selectedColumns[key] ? 'active' : ''}" onclick="toggleColumn('${key}')">
                    <input type="checkbox" ${selectedColumns[key] ? 'checked' : ''} onchange="toggleColumn('${key}')" onclick="event.stopPropagation()">
                    ${config.label}
                </label>
            `).join('');
        }
        
        // Toggle column visibility
        function toggleColumn(columnKey) {
            selectedColumns[columnKey] = !selectedColumns[columnKey];
            renderColumnOptions();
            // Re-render results if we have data
            if (Object.keys(fetchedData).length > 0) {
                displayResults();
            }
        }
        
        // Toggle column selector expand/collapse
        function toggleColumnSelector() {
            const selector = document.getElementById('columnSelector');
            const icon = document.getElementById('toggleIcon');
            selector.classList.toggle('expanded');
            icon.textContent = selector.classList.contains('expanded') ? '▼' : '▶';
        }
        
        // Toggle card collapse (for results sections)
        function toggleCardCollapse(cardId) {
            const card = document.getElementById(cardId);
            const title = card.querySelector('.card-title');
            const content = card.querySelector('.card-content');
            
            title.classList.toggle('collapsed');
            content.classList.toggle('collapsed');
        }
        
        // Get list of visible columns
        function getVisibleColumns() {
            return Object.keys(selectedColumns).filter(col => selectedColumns[col]);
        }

        // Show status message
        function showStatus(elementId, message, type = 'loading') {
            const el = document.getElementById(elementId);
            el.textContent = message;
            el.className = `status show ${type}`;
        }

        function hideStatus(elementId) {
            document.getElementById(elementId).className = 'status';
        }

        // Step 1: Lookup accounts
        async function lookupAccounts() {
            const l1Address = document.getElementById('l1Address').value.trim();
            if (!l1Address) {
                showStatus('lookupStatus', 'Please enter an L1 address', 'error');
                return;
            }

            const btn = document.getElementById('lookupBtn');
            btn.disabled = true;
            btn.innerHTML = '<span class="spinner"></span>Looking up...';
            showStatus('lookupStatus', 'Fetching account indexes...', 'loading');

            try {
                const response = await fetch('/api/lookup-accounts', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ l1_address: l1Address })
                });

                const data = await response.json();
                if (!response.ok) {
                    throw new Error(data.detail || 'Failed to lookup accounts');
                }

                accountIndexes = data.account_indexes;
                showStatus('lookupStatus', `Found ${accountIndexes.length} account(s)`, 'success');
                
                // Show step 2 (read-only token input)
                document.getElementById('step2Card').classList.remove('hidden');

            } catch (error) {
                showStatus('lookupStatus', `Error: ${error.message}`, 'error');
            } finally {
                btn.disabled = false;
                btn.textContent = 'Lookup Accounts';
            }
        }

        // Continue to account selection after entering read-only token
        function continueToAccountSelection() {
            const token = document.getElementById('readOnlyToken').value.trim();
            if (!token) {
                showStatus('tokenStatus', 'Please enter a read-only token', 'error');
                return;
            }
            
            // Validate token format: ro:account_index:scope:expiry:signature
            if (!token.startsWith('ro:')) {
                showStatus('tokenStatus', 'Invalid read-only token format. Token must start with "ro:"', 'error');
                return;
            }
            
            readOnlyToken = token;
            showStatus('tokenStatus', 'Token validated', 'success');
            
            // Build account selection UI
            buildAccountsList();
            document.getElementById('step3Card').classList.remove('hidden');
        }

        // Build accounts list with checkboxes only
        function buildAccountsList() {
            const container = document.getElementById('accountsList');
            container.innerHTML = '';

            accountIndexes.forEach((index, i) => {
                // Validate index is a number to prevent injection
                const safeIndex = parseInt(index, 10);
                if (isNaN(safeIndex)) return;
                
                const isFirst = i === 0;
                const div = document.createElement('div');
                div.className = `account-item ${isFirst ? 'selected' : ''}`;
                div.id = `account-${safeIndex}`;
                div.innerHTML = `
                    <div class="account-header">
                        <input type="checkbox" id="check-${safeIndex}" ${isFirst ? 'checked' : ''} 
                            onchange="toggleAccount(${safeIndex})">
                        <label for="check-${safeIndex}">Account Index: <strong>${safeIndex}</strong></label>
                    </div>
                `;
                container.appendChild(div);
            });
        }

        // Toggle account selection
        function toggleAccount(index) {
            const item = document.getElementById(`account-${index}`);
            const checkbox = document.getElementById(`check-${index}`);
            if (checkbox.checked) {
                item.classList.add('selected');
            } else {
                item.classList.remove('selected');
            }
        }

        // Get selected account indexes
        function getSelectedAccounts() {
            const selected = [];
            accountIndexes.forEach(index => {
                const checkbox = document.getElementById(`check-${index}`);
                if (checkbox && checkbox.checked) {
                    selected.push(parseInt(index, 10));
                }
            });
            return selected;
        }

        // Lighter API base URL
        const LIGHTER_API = 'https://mainnet.zklighter.elliot.ai';
        const RATE_LIMIT_DELAY = 3500; // 3.5s between trade calls (20/min limit)
        const FUNDING_RATE_LIMIT_DELAY = 1000; // 1s between funding calls (60/min limit)
        const WALLET_RATE_LIMIT_DELAY = 1000; // 1s between wallet calls (60/min limit)
        
        // Helper to disable/enable all fetch buttons
        function setAllFetchButtonsDisabled(disabled) {
            ['fetchTradesBtn', 'fetchFundingBtn', 'fetchDepositsBtn', 'fetchTransfersBtn', 'fetchWithdrawalsBtn'].forEach(id => {
                const btn = document.getElementById(id);
                if (btn) btn.disabled = disabled;
            });
        }
        
        // Timeframe selector functions
        function selectTimeframe(type) {
            selectedTimeframe = type;
            
            // Update UI
            document.querySelectorAll('.timeframe-option').forEach(opt => {
                opt.classList.remove('active');
            });
            
            if (type === 'complete') {
                document.getElementById('timeframeComplete').checked = true;
                document.querySelector('.timeframe-option:nth-child(1)').classList.add('active');
                document.getElementById('dateRangeInputs').classList.remove('visible');
                document.getElementById('timeRangeInputs').classList.remove('visible');
            } else {
                document.getElementById('timeframeCustom').checked = true;
                document.querySelector('.timeframe-option:nth-child(2)').classList.add('active');
                document.getElementById('dateRangeInputs').classList.add('visible');
                
                // Set default dates if not already set
                const dateFromInput = document.getElementById('dateFrom');
                const dateToInput = document.getElementById('dateTo');
                
                if (!dateFromInput.value) {
                    // Default: 1 year ago
                    const oneYearAgo = new Date();
                    oneYearAgo.setFullYear(oneYearAgo.getFullYear() - 1);
                    dateFromInput.value = formatDateOnly(oneYearAgo);
                }
                
                if (!dateToInput.value) {
                    // Default: today
                    dateToInput.value = formatDateOnly(new Date());
                }
            }
        }
        
        function toggleHoursSelection() {
            const checkbox = document.getElementById('includeHours');
            const timeInputs = document.getElementById('timeRangeInputs');
            
            if (checkbox.checked) {
                timeInputs.classList.add('visible');
            } else {
                timeInputs.classList.remove('visible');
                // Reset to default times
                document.getElementById('timeFrom').value = '00:00';
                document.getElementById('timeTo').value = '23:59';
            }
        }
        
        function formatDateOnly(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }
        
        function getTimeframeParams() {
            if (selectedTimeframe === 'complete') {
                return { fromTimestamp: null, toTimestamp: null };
            }
            
            const dateFromInput = document.getElementById('dateFrom');
            const dateToInput = document.getElementById('dateTo');
            const includeHours = document.getElementById('includeHours').checked;
            
            if (!dateFromInput.value || !dateToInput.value) {
                return { fromTimestamp: null, toTimestamp: null };
            }
            
            let fromTimestamp, toTimestamp;
            
            if (includeHours) {
                // Use specific times from time inputs (UTC to match API timestamps)
                const timeFromInput = document.getElementById('timeFrom');
                const timeToInput = document.getElementById('timeTo');
                const timeFrom = timeFromInput.value || '00:00';
                const timeTo = timeToInput.value || '23:59';
                
                fromTimestamp = new Date(`${dateFromInput.value}T${timeFrom}:00.000Z`).getTime();
                toTimestamp = new Date(`${dateToInput.value}T${timeTo}:59.999Z`).getTime();
            } else {
                // Use start of day for from, end of day for to (UTC to match API timestamps)
                fromTimestamp = new Date(`${dateFromInput.value}T00:00:00.000Z`).getTime();
                toTimestamp = new Date(`${dateToInput.value}T23:59:59.999Z`).getTime();
            }
            
            return { fromTimestamp, toTimestamp };
        }
        
        function validateTimeframe() {
            if (selectedTimeframe === 'complete') {
                return true;
            }
            
            const { fromTimestamp, toTimestamp } = getTimeframeParams();
            
            if (!fromTimestamp || !toTimestamp) {
                showStatus('fetchStatus', 'Please select both start and end dates', 'error');
                return false;
            }
            
            if (fromTimestamp >= toTimestamp) {
                showStatus('fetchStatus', 'Start date must be before end date', 'error');
                return false;
            }
            
            return true;
        }
        
        // Fetch trades from Lighter API directly (client-side)
        // Uses headers for auth token (not visible in URL/console)
        // Supports optional timeframe filtering via fromTimestamp (start) and toTimestamp (end) in ms
        // NOTE: The API's 'from' parameter returns trades FROM that timestamp going BACKWARDS (older)
        // So we set 'from' to toTimestamp (end date) and stop when we hit fromTimestamp (start date)
        async function fetchTradesFromLighter(authToken, accountIndex, fromTimestamp = null, toTimestamp = null) {
            const allTrades = [];
            let cursor = null;
            let page = 0;
            let reachedStart = false;
            
            while (true) {
                page++;
                const params = new URLSearchParams({
                    account_index: accountIndex,
                    sort_by: 'timestamp',
                    limit: 100
                });
                
                // The 'from' parameter tells the API to start from this timestamp and go backwards
                // So we use the END date (toTimestamp) as the starting point
                if (toTimestamp && !cursor) {
                    params.append('from', Math.floor(toTimestamp / 1000));
                }
                
                if (cursor) {
                    params.append('cursor', cursor);
                }
                
                const timeframeMsg = toTimestamp ? ' (filtered)' : '';
                showStatus('fetchStatus', `Account #${accountIndex}: Fetching page ${page}${timeframeMsg}...`, 'loading');
                
                try {
                    const response = await fetch(`${LIGHTER_API}/api/v1/trades?${params}`, {
                        headers: { 'Authorization': authToken }
                    });
                    
                    if (response.status === 429) {
                        showStatus('fetchStatus', `Rate limited, waiting 15s...`, 'loading');
                        await new Promise(r => setTimeout(r, 15000));
                        continue;
                    }
                    
                    if (!response.ok) {
                        console.error(`HTTP error: ${response.status}`);
                        break;
                    }
                    
                    const data = await response.json();
                    if (data.code !== 200) {
                        console.error(`API error: ${data.code}`);
                        break;
                    }
                    
                    let trades = data.trades || [];
                    
                    // If we have a start timestamp (fromTimestamp), check if we should stop
                    // Trades come in descending order (newest first), so we stop when we hit trades older than fromTimestamp
                    if (fromTimestamp && trades.length > 0) {
                        const filteredTrades = [];
                        for (const trade of trades) {
                            const tradeTime = trade.timestamp;
                            if (tradeTime >= fromTimestamp) {
                                filteredTrades.push(trade);
                            } else {
                                reachedStart = true;
                            }
                        }
                        trades = filteredTrades;
                    }
                    
                    allTrades.push(...trades);
                    
                    if (!data.next_cursor || trades.length === 0 || reachedStart) {
                        break;
                    }
                    
                    cursor = data.next_cursor;
                    
                    // Rate limit delay
                    await new Promise(r => setTimeout(r, RATE_LIMIT_DELAY));
                    
                } catch (error) {
                    console.error(`Error fetching trades: ${error}`);
                    break;
                }
            }
            
            // Final filter to ensure all trades are within the timeframe
            if (fromTimestamp || toTimestamp) {
                return allTrades.filter(trade => {
                    const tradeTime = trade.timestamp;
                    const afterStart = fromTimestamp ? tradeTime >= fromTimestamp : true;
                    const beforeEnd = toTimestamp ? tradeTime <= toTimestamp : true;
                    return afterStart && beforeEnd;
                });
            }
            
            return allTrades;
        }

        // Step 3: Fetch trades
        async function fetchTrades() {
            if (!readOnlyToken) {
                showStatus('fetchStatus', 'Please enter a read-only token first', 'error');
                return;
            }
            
            const selectedAccounts = getSelectedAccounts();
            if (selectedAccounts.length === 0) {
                showStatus('fetchStatus', 'Please select at least one account', 'error');
                return;
            }
            
            // Validate timeframe
            if (!validateTimeframe()) {
                return;
            }
            
            const { fromTimestamp, toTimestamp } = getTimeframeParams();

            const btn = document.getElementById('fetchTradesBtn');
            setAllFetchButtonsDisabled(true);
            btn.innerHTML = '<span class="spinner"></span>Fetching...';
            
            try {
                // Fetch trades for all selected accounts using the single read-only token
                fetchedData = {};
                rawTradesData = {};
                
                for (const accountIndex of selectedAccounts) {
                    // Fetch raw trades from Lighter with optional timeframe
                    const rawTrades = await fetchTradesFromLighter(readOnlyToken, accountIndex, fromTimestamp, toTimestamp);
                    
                    // Store raw trades for JSON export
                    rawTradesData[accountIndex] = rawTrades;
                    
                    // Process trades through our server (adds market names, PnL, etc.)
                    showStatus('fetchStatus', `Processing ${rawTrades.length} trades for account #${accountIndex}...`, 'loading');
                    
                    const processResponse = await fetch('/api/process-trades', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            account_index: accountIndex,
                            trades: rawTrades
                        })
                    });
                    
                    const processedData = await processResponse.json();
                    
                    if (processResponse.ok && processedData.success) {
                        fetchedData[accountIndex] = {
                            success: true,
                            total_trades: processedData.total_trades,
                            trades: processedData.trades
                        };
                    } else {
                        fetchedData[accountIndex] = {
                            success: false,
                            error: processedData.detail || 'Processing failed',
                            total_trades: 0,
                            trades: []
                        };
                    }
                }
                
                // Count total trades
                let totalTrades = 0;
                Object.values(fetchedData).forEach(acc => {
                    totalTrades += acc.total_trades || 0;
                });

                showStatus('fetchStatus', `Successfully fetched ${totalTrades} trades`, 'success');
                
                // Initialize column selection and display results
                initColumnSelection();
                displayResults();
                document.getElementById('resultsCard').classList.remove('hidden');

            } catch (error) {
                showStatus('fetchStatus', `Error: ${error.message}`, 'error');
            } finally {
                setAllFetchButtonsDisabled(false);
                btn.textContent = 'Fetch Trades';
            }
        }

        // Display results with tabs
        function displayResults() {
            const tabsContainer = document.getElementById('accountTabs');
            const contentsContainer = document.getElementById('accountContents');
            tabsContainer.innerHTML = '';
            contentsContainer.innerHTML = '';

            const accountIds = Object.keys(fetchedData);
            const visibleCols = getVisibleColumns();
            
            accountIds.forEach((accountIndex, i) => {
                const accountData = fetchedData[accountIndex];
                const isFirst = i === 0;

                // Create tab
                const tab = document.createElement('div');
                tab.className = `tab ${isFirst ? 'active' : ''}`;
                tab.textContent = `Account #${accountIndex}`;
                tab.onclick = () => switchTab(accountIndex);
                tab.id = `tab-${accountIndex}`;
                tabsContainer.appendChild(tab);

                // Create content
                const content = document.createElement('div');
                content.className = `tab-content ${isFirst ? 'active' : ''}`;
                content.id = `content-${accountIndex}`;

                if (!accountData.success) {
                    content.innerHTML = `<div class="error-message">Error: ${escapeHtml(accountData.error)}</div>`;
                } else if (accountData.trades.length === 0) {
                    content.innerHTML = `<div class="error-message">No trades found for this account</div>`;
                } else {
                    const safeAccountIndex = parseInt(accountIndex, 10);
                    const safeTotal = parseInt(accountData.total_trades, 10) || 0;
                    const filteredTrades = getFilteredTrades(accountData.trades);
                    const displayCount = filteredTrades.length;
                    const statsText = displayCount === safeTotal ? `${safeTotal} trades` : `${displayCount} of ${safeTotal} trades`;
                    content.innerHTML = `
                        <div class="results-header">
                            <span class="results-stats">${statsText}</span>
                            <div style="display: flex; gap: 8px;">
                                <button class="btn-secondary btn-small" onclick="exportCSV(${safeAccountIndex})">
                                    CSV
                                </button>
                                <button class="btn-secondary btn-small" onclick="exportJSON(${safeAccountIndex})">
                                    JSON
                                </button>
                            </div>
                        </div>
                        <div class="results-box">
                            ${buildTradesTable(filteredTrades, visibleCols)}
                        </div>
                    `;
                }

                contentsContainer.appendChild(content);
            });
        }

        // Build trades table HTML
        function buildTradesTable(trades, visibleCols) {
            if (visibleCols.length === 0) {
                return '<p style="color: var(--text-secondary); padding: 20px;">No columns selected. Use the column selector above.</p>';
            }
            
            // Build header
            let html = '<table class="trades-table"><thead><tr>';
            visibleCols.forEach(col => {
                html += `<th>${ALL_COLUMNS[col].label}</th>`;
            });
            html += '</tr></thead><tbody>';
            
            // Build rows
            trades.forEach(trade => {
                html += '<tr>';
                visibleCols.forEach(col => {
                    html += `<td>${formatCell(trade, col)}</td>`;
                });
                html += '</tr>';
            });
            
            html += '</tbody></table>';
            return html;
        }
        
        // Format cell value based on column type (with XSS protection)
        function formatCell(trade, col) {
            const value = trade[col];
            
            switch(col) {
                case 'market':
                    return `<span class="trade-market">${escapeHtml(value)}</span>`;
                case 'market_type':
                    const typeClass = value === 'Spot' ? 'type-spot' : 'type-perp';
                    return `<span class="market-type ${typeClass}">${escapeHtml(value)}</span>`;
                case 'side':
                    const safeValue = escapeHtml(value);
                    // Green for buy actions: Open Long, Increase Long, Close Short, Reduce Short, Short > Long
                    // Red for sell actions: Open Short, Increase Short, Close Long, Reduce Long, Long > Short
                    const isBuyAction = ['Open Long', 'Increase Long', 'Close Short', 'Reduce Short', 'Short > Long'].includes(value);
                    const sideClass = isBuyAction ? 'long' : 'short';
                    return `<span class="trade-side ${sideClass}">${safeValue}</span>`;
                case 'trade_value_usd':
                case 'price_usd':
                    const numVal = parseFloat(value) || 0;
                    return `$${numVal.toFixed(2)}`;
                case 'fee_usd':
                    const feeVal = parseFloat(value) || 0;
                    return `$${feeVal.toFixed(4)}`;
                case 'pnl_usd':
                    if (value === null) return '-';
                    const pnlVal = parseFloat(value) || 0;
                    const pnlClass = pnlVal >= 0 ? 'profit' : 'loss';
                    const sign = pnlVal >= 0 ? '+' : '';
                    return `<span class="trade-pnl ${pnlClass}">${sign}$${pnlVal.toFixed(2)}</span>`;
                case 'tx_hash':
                    if (!value) return '<span class="tx-hash">N/A</span>';
                    const safeHash = escapeHtml(value);
                    const shortHash = String(value).substring(0, 16);
                    return `<span class="copyable" data-copy="${safeHash}" onclick="copyToClipboard(this)" title="Click to copy full hash">
                        <span class="tx-hash">${escapeHtml(shortHash)}...</span>${COPY_ICON_SVG}
                    </span>`;
                case 'trade_id':
                    return escapeHtml(parseInt(value, 10) || value);
                case 'size':
                    const sizeVal = parseFloat(value) || 0;
                    return sizeVal.toString();
                default:
                    return escapeHtml(value);
            }
        }

        // Switch tab
        function switchTab(accountIndex) {
            // Update tabs
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.getElementById(`tab-${accountIndex}`).classList.add('active');

            // Update contents
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            document.getElementById(`content-${accountIndex}`).classList.add('active');
        }

        // Export CSV for a specific account (only selected columns)
        function exportCSV(accountIndex) {
            const accountData = fetchedData[accountIndex];
            if (!accountData || !accountData.trades || accountData.trades.length === 0) {
                alert('No trades to export for this account');
                return;
            }

            const trades = getFilteredTrades(accountData.trades);
            if (trades.length === 0) {
                alert('No trades match the current filters');
                return;
            }
            const visibleCols = getVisibleColumns();
            
            if (visibleCols.length === 0) {
                alert('Please select at least one column to export');
                return;
            }
            
            // CSV header
            const headers = visibleCols.map(col => ALL_COLUMNS[col].label);
            
            // Build CSV content
            const csvRows = [headers.join(',')];
            
            for (const trade of trades) {
                const row = visibleCols.map(col => {
                    const value = trade[col];
                    if (value === null || value === undefined) return '';
                    if (typeof value === 'string') return `"${value.replace(/"/g, '""')}"`;
                    return value;
                });
                csvRows.push(row.join(','));
            }
            
            const csvContent = csvRows.join('\n');
            
            // Generate filename
            const now = new Date();
            const timestamp = now.toISOString().replace(/[:.]/g, '-').slice(0, 19);
            const filename = `lighter_trades_account_${accountIndex}_${timestamp}.csv`;

            // Download
            const BOM = '\uFEFF';
            const encodedContent = encodeURIComponent(BOM + csvContent);
            const dataUri = `data:text/csv;charset=utf-8,${encodedContent}`;
            
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = dataUri;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            a.remove();
        }
        
        // Export JSON for a specific account (raw data)
        function exportJSON(accountIndex) {
            const rawTrades = rawTradesData[accountIndex];
            if (!rawTrades || rawTrades.length === 0) {
                alert('No trades to export for this account');
                return;
            }
            
            const jsonContent = JSON.stringify({
                exported_at: new Date().toISOString(),
                account_index: accountIndex,
                total_trades: rawTrades.length,
                trades: rawTrades
            }, null, 2);
            
            // Generate filename
            const now = new Date();
            const timestamp = now.toISOString().replace(/[:.]/g, '-').slice(0, 19);
            const filename = `lighter_trades_account_${accountIndex}_${timestamp}.json`;
            
            // Download
            const blob = new Blob([jsonContent], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            
            setTimeout(() => {
                URL.revokeObjectURL(url);
                a.remove();
            }, 100);
        }
        
        // ===== FUNDING PAYMENTS =====
        
        // Fetch funding from Lighter API
        // For funding, there's no 'from' parameter, so we fetch from the beginning and filter
        // Funding API: data comes in descending order (newest first)
        // We fetch from the beginning and stop when we hit events older than fromTimestamp (start date)
        async function fetchFundingFromLighter(authToken, accountIndex, fromTimestamp = null, toTimestamp = null) {
            const allFundings = [];
            let cursor = null;
            let page = 0;
            let reachedStart = false;
            
            // Convert to seconds for funding API (uses seconds, not ms)
            const fromSec = fromTimestamp ? Math.floor(fromTimestamp / 1000) : null;
            const toSec = toTimestamp ? Math.floor(toTimestamp / 1000) : null;
            
            while (true) {
                page++;
                const params = new URLSearchParams({
                    account_index: accountIndex,
                    limit: 100
                });
                if (cursor) {
                    params.append('cursor', cursor);
                }
                
                const timeframeMsg = fromTimestamp ? ' (filtered)' : '';
                showStatus('fetchStatus', `Account #${accountIndex}: Fetching funding page ${page}${timeframeMsg}...`, 'loading');
                
                try {
                    const response = await fetch(`${LIGHTER_API}/api/v1/positionFunding?${params}`, {
                        headers: { 'Authorization': authToken }
                    });
                    
                    if (response.status === 429) {
                        showStatus('fundingStatus', `Rate limited, waiting 15s...`, 'loading');
                        await new Promise(r => setTimeout(r, 15000));
                        continue;
                    }
                    
                    if (!response.ok) {
                        console.error(`HTTP error: ${response.status}`);
                        break;
                    }
                    
                    const data = await response.json();
                    if (data.code !== 200) {
                        console.error(`API error: ${data.code}`);
                        break;
                    }
                    
                    let fundings = data.position_fundings || [];
                    
                    // Data comes in descending order (newest first)
                    // If we have a start timestamp, stop when we hit events older than it
                    if (fromSec && fundings.length > 0) {
                        const filteredFundings = [];
                        for (const funding of fundings) {
                            if (funding.timestamp >= fromSec) {
                                // Event is within range (newer than or equal to start date)
                                filteredFundings.push(funding);
                            } else {
                                // Event is older than start date - stop fetching
                                reachedStart = true;
                            }
                        }
                        fundings = filteredFundings;
                    }
                    
                    allFundings.push(...fundings);
                    
                    if (!data.next_cursor || fundings.length === 0 || reachedStart) {
                        break;
                    }
                    
                    cursor = data.next_cursor;
                    await new Promise(r => setTimeout(r, FUNDING_RATE_LIMIT_DELAY));
                    
                } catch (error) {
                    console.error(`Error fetching funding: ${error}`);
                    break;
                }
            }
            
            // Final filter to ensure all fundings are within the timeframe
            if (fromSec || toSec) {
                return allFundings.filter(funding => {
                    const afterStart = fromSec ? funding.timestamp >= fromSec : true;
                    const beforeEnd = toSec ? funding.timestamp <= toSec : true;
                    return afterStart && beforeEnd;
                });
            }
            
            return allFundings;
        }
        
        // Fetch funding for all selected accounts
        async function fetchFunding() {
            if (!readOnlyToken) {
                showStatus('fetchStatus', 'Please enter a read-only token first', 'error');
                return;
            }
            
            const selectedAccounts = getSelectedAccounts();
            if (selectedAccounts.length === 0) {
                showStatus('fetchStatus', 'Please select at least one account', 'error');
                return;
            }
            
            // Validate timeframe
            if (!validateTimeframe()) {
                return;
            }
            
            const { fromTimestamp, toTimestamp } = getTimeframeParams();
            
            const btn = document.getElementById('fetchFundingBtn');
            setAllFetchButtonsDisabled(true);
            btn.innerHTML = '<span class="spinner"></span>Fetching...';
            
            try {
                fundingData = {};
                rawFundingData = {};
                
                for (const accountIndex of selectedAccounts) {
                    const rawFundings = await fetchFundingFromLighter(readOnlyToken, accountIndex, fromTimestamp, toTimestamp);
                    rawFundingData[accountIndex] = rawFundings;
                    
                    // Process funding data
                    const processed = await processFundingData(rawFundings, accountIndex);
                    fundingData[accountIndex] = {
                        success: true,
                        total_fundings: processed.length,
                        fundings: processed
                    };
                }
                
                let totalFundings = 0;
                Object.values(fundingData).forEach(acc => {
                    totalFundings += acc.total_fundings || 0;
                });
                
                showStatus('fetchStatus', `Successfully fetched ${totalFundings} funding payments`, 'success');
                displayFundingResults();
                document.getElementById('fundingCard').classList.remove('hidden');
                
            } catch (error) {
                showStatus('fetchStatus', `Error: ${error.message}`, 'error');
            } finally {
                setAllFetchButtonsDisabled(false);
                btn.textContent = 'Fetch Funding';
            }
        }
        
        // Process funding data (add market names, format values)
        async function processFundingData(rawFundings, accountIndex) {
            // Get market map from server
            const response = await fetch('/api/markets');
            const marketData = await response.json();
            const marketMap = marketData.markets || {};
            
            return rawFundings.map(f => {
                const marketName = marketMap[f.market_id] || `ID:${f.market_id}`;
                const timestamp = f.timestamp * 1000; // Convert to ms
                const dt = new Date(timestamp);
                const dateStr = dt.toISOString().replace('T', ' ').slice(0, 19) + ' UTC';
                
                return {
                    funding_id: f.funding_id,
                    market: marketName,
                    datetime_utc: dateStr,
                    change_usd: parseFloat(f.change),
                    rate_percent: (parseFloat(f.rate) * 100).toFixed(4),
                    size: parseFloat(f.position_size),
                    side: f.position_side
                };
            });
        }
        
        // Display funding results
        function displayFundingResults() {
            const tabsContainer = document.getElementById('fundingTabs');
            const contentsContainer = document.getElementById('fundingContents');
            tabsContainer.innerHTML = '';
            contentsContainer.innerHTML = '';
            
            const accountIds = Object.keys(fundingData);
            
            accountIds.forEach((accountIndex, i) => {
                const accountData = fundingData[accountIndex];
                const isFirst = i === 0;
                
                // Create tab
                const tab = document.createElement('div');
                tab.className = `tab ${isFirst ? 'active' : ''}`;
                tab.textContent = `Account #${accountIndex}`;
                tab.onclick = () => switchFundingTab(accountIndex);
                tab.id = `funding-tab-${accountIndex}`;
                tabsContainer.appendChild(tab);
                
                // Create content
                const content = document.createElement('div');
                content.className = `tab-content ${isFirst ? 'active' : ''}`;
                content.id = `funding-content-${accountIndex}`;
                
                if (!accountData.success || accountData.fundings.length === 0) {
                    content.innerHTML = `<div class="error-message">No funding payments found</div>`;
                } else {
                    const safeAccountIndex = parseInt(accountIndex, 10);
                    const safeTotal = parseInt(accountData.total_fundings, 10) || 0;
                    content.innerHTML = `
                        <div class="results-header">
                            <span class="results-stats">${safeTotal} funding payments</span>
                            <div style="display: flex; gap: 8px;">
                                <button class="btn-secondary btn-small" onclick="exportFundingCSV(${safeAccountIndex})">
                                    CSV
                                </button>
                                <button class="btn-secondary btn-small" onclick="exportFundingJSON(${safeAccountIndex})">
                                    JSON
                                </button>
                            </div>
                        </div>
                        <div class="results-box">
                            ${buildFundingTable(accountData.fundings)}
                        </div>
                    `;
                }
                
                contentsContainer.appendChild(content);
            });
        }
        
        // Build funding table (with XSS protection)
        function buildFundingTable(fundings) {
            let html = '<table class="trades-table"><thead><tr>';
            html += '<th>Market</th><th>Date/Time</th><th>Change ($)</th><th>Rate (%)</th><th>Size</th><th>Side</th>';
            html += '</tr></thead><tbody>';
            
            fundings.forEach(f => {
                const changeVal = parseFloat(f.change_usd) || 0;
                const changeClass = changeVal >= 0 ? 'profit' : 'loss';
                const changeSign = changeVal >= 0 ? '+' : '';
                const safeSide = String(f.side || '').toLowerCase();
                const sideClass = safeSide === 'long' ? 'long' : 'short';
                const sizeVal = parseFloat(f.size) || 0;
                const rateVal = escapeHtml(f.rate_percent);
                
                html += `<tr>
                    <td><span class="trade-market">${escapeHtml(f.market)}</span></td>
                    <td>${escapeHtml(f.datetime_utc)}</td>
                    <td><span class="trade-pnl ${changeClass}">${changeSign}$${changeVal.toFixed(6)}</span></td>
                    <td>${rateVal}%</td>
                    <td>${sizeVal}</td>
                    <td><span class="trade-side ${sideClass}">${escapeHtml(f.side)}</span></td>
                </tr>`;
            });
            
            html += '</tbody></table>';
            return html;
        }
        
        // Switch funding tab
        function switchFundingTab(accountIndex) {
            document.querySelectorAll('#fundingTabs .tab').forEach(t => t.classList.remove('active'));
            document.getElementById(`funding-tab-${accountIndex}`).classList.add('active');
            
            document.querySelectorAll('#fundingContents .tab-content').forEach(c => c.classList.remove('active'));
            document.getElementById(`funding-content-${accountIndex}`).classList.add('active');
        }
        
        // Export funding as CSV
        function exportFundingCSV(accountIndex) {
            const data = fundingData[accountIndex];
            if (!data || !data.fundings || data.fundings.length === 0) {
                alert('No funding to export');
                return;
            }
            
            const headers = ['Market', 'Date/Time', 'Change ($)', 'Rate (%)', 'Size', 'Side'];
            const csvRows = [headers.join(',')];
            
            data.fundings.forEach(f => {
                csvRows.push([
                    `"${f.market}"`,
                    `"${f.datetime_utc}"`,
                    f.change_usd,
                    f.rate_percent,
                    f.size,
                    `"${f.side}"`
                ].join(','));
            });
            
            const csvContent = csvRows.join('\n');
            const now = new Date();
            const timestamp = now.toISOString().replace(/[:.]/g, '-').slice(0, 19);
            const filename = `lighter_funding_account_${accountIndex}_${timestamp}.csv`;
            
            const BOM = '\uFEFF';
            const encodedContent = encodeURIComponent(BOM + csvContent);
            const dataUri = `data:text/csv;charset=utf-8,${encodedContent}`;
            
            const a = document.createElement('a');
            a.href = dataUri;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            a.remove();
        }
        
        // Export funding as JSON
        function exportFundingJSON(accountIndex) {
            const rawFundings = rawFundingData[accountIndex];
            if (!rawFundings || rawFundings.length === 0) {
                alert('No funding to export');
                return;
            }
            
            const jsonContent = JSON.stringify({
                exported_at: new Date().toISOString(),
                account_index: parseInt(accountIndex),
                total_fundings: rawFundings.length,
                position_fundings: rawFundings
            }, null, 2);
            
            const now = new Date();
            const timestamp = now.toISOString().replace(/[:.]/g, '-').slice(0, 19);
            const filename = `lighter_funding_account_${accountIndex}_${timestamp}.json`;
            
            const blob = new Blob([jsonContent], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            
            setTimeout(() => {
                URL.revokeObjectURL(url);
                a.remove();
            }, 100);
        }
        
        // ===== DEPOSITS =====
        
        // Get L1 address from input
        function getL1Address() {
            return document.getElementById('l1Address').value.trim();
        }
        
        // Fetch deposits from Lighter API
        // Deposits timestamp is in milliseconds
        // Deposits API: data comes in descending order (newest first)
        // We fetch from the beginning and stop when we hit events older than fromTimestamp (start date)
        async function fetchDepositsFromLighter(authToken, accountIndex, fromTimestamp = null, toTimestamp = null) {
            const allDeposits = [];
            let cursor = null;
            let page = 0;
            let reachedStart = false;
            const l1Address = getL1Address();
            
            while (true) {
                page++;
                const params = new URLSearchParams({
                    account_index: accountIndex,
                    l1_address: l1Address
                });
                if (cursor) {
                    params.append('cursor', cursor);
                }
                
                const timeframeMsg = fromTimestamp ? ' (filtered)' : '';
                showStatus('fetchStatus', `Account #${accountIndex}: Fetching deposits page ${page}${timeframeMsg}...`, 'loading');
                
                try {
                    const response = await fetch(`${LIGHTER_API}/api/v1/deposit/history?${params}`, {
                        headers: { 'Authorization': authToken }
                    });
                    
                    if (response.status === 429) {
                        showStatus('fetchStatus', `Rate limited, waiting 15s...`, 'loading');
                        await new Promise(r => setTimeout(r, 15000));
                        continue;
                    }
                    
                    if (!response.ok) {
                        console.error(`HTTP error: ${response.status}`);
                        break;
                    }
                    
                    const data = await response.json();
                    if (data.code !== 200) {
                        console.error(`API error: ${data.code}`);
                        break;
                    }
                    
                    let deposits = data.deposits || [];
                    
                    // Data comes in descending order (newest first)
                    // If we have a start timestamp, stop when we hit events older than it
                    if (fromTimestamp && deposits.length > 0) {
                        const filteredDeposits = [];
                        for (const deposit of deposits) {
                            if (deposit.timestamp >= fromTimestamp) {
                                // Event is within range (newer than or equal to start date)
                                filteredDeposits.push(deposit);
                            } else {
                                // Event is older than start date - stop fetching
                                reachedStart = true;
                            }
                        }
                        deposits = filteredDeposits;
                    }
                    
                    allDeposits.push(...deposits);
                    
                    if (!data.cursor || deposits.length === 0 || reachedStart) {
                        break;
                    }
                    
                    cursor = data.cursor;
                    await new Promise(r => setTimeout(r, WALLET_RATE_LIMIT_DELAY));
                    
                } catch (error) {
                    console.error(`Error fetching deposits: ${error}`);
                    break;
                }
            }
            
            // Final filter to ensure all deposits are within the timeframe
            if (fromTimestamp || toTimestamp) {
                return allDeposits.filter(deposit => {
                    const afterStart = fromTimestamp ? deposit.timestamp >= fromTimestamp : true;
                    const beforeEnd = toTimestamp ? deposit.timestamp <= toTimestamp : true;
                    return afterStart && beforeEnd;
                });
            }
            
            return allDeposits;
        }
        
        // Fetch deposits for all selected accounts
        async function fetchDeposits() {
            if (!readOnlyToken) {
                showStatus('fetchStatus', 'Please enter a read-only token first', 'error');
                return;
            }
            
            const selectedAccounts = getSelectedAccounts();
            if (selectedAccounts.length === 0) {
                showStatus('fetchStatus', 'Please select at least one account', 'error');
                return;
            }
            
            // Validate timeframe
            if (!validateTimeframe()) {
                return;
            }
            
            const { fromTimestamp, toTimestamp } = getTimeframeParams();
            
            const btn = document.getElementById('fetchDepositsBtn');
            setAllFetchButtonsDisabled(true);
            btn.innerHTML = '<span class="spinner"></span>Fetching...';
            
            try {
                // Fetch asset details first
                await fetchAssetDetails();
                
                depositsData = {};
                rawDepositsData = {};
                
                for (const accountIndex of selectedAccounts) {
                    const rawDeposits = await fetchDepositsFromLighter(readOnlyToken, accountIndex, fromTimestamp, toTimestamp);
                    rawDepositsData[accountIndex] = rawDeposits;
                    
                    // Process deposits
                    const processed = processDeposits(rawDeposits);
                    depositsData[accountIndex] = {
                        success: true,
                        total_deposits: processed.length,
                        deposits: processed
                    };
                }
                
                let totalDeposits = 0;
                Object.values(depositsData).forEach(acc => {
                    totalDeposits += acc.total_deposits || 0;
                });
                
                showStatus('fetchStatus', `Successfully fetched ${totalDeposits} deposits`, 'success');
                displayDepositsResults();
                document.getElementById('depositsCard').classList.remove('hidden');
                
            } catch (error) {
                showStatus('fetchStatus', `Error: ${error.message}`, 'error');
            } finally {
                setAllFetchButtonsDisabled(false);
                btn.textContent = 'Fetch Deposits';
            }
        }
        
        // Process deposits data
        function processDeposits(rawDeposits) {
            return rawDeposits.map(d => {
                const timestamp = d.timestamp;
                const dt = new Date(timestamp);
                const dateStr = dt.toISOString().replace('T', ' ').slice(0, 19) + ' UTC';
                
                return {
                    id: d.id,
                    asset: getAssetSymbol(d.asset_id),
                    amount: d.amount,
                    datetime_utc: dateStr,
                    l1_tx_hash: d.l1_tx_hash
                };
            });
        }
        
        // Display deposits results
        function displayDepositsResults() {
            const tabsContainer = document.getElementById('depositsTabs');
            const contentsContainer = document.getElementById('depositsContents');
            tabsContainer.innerHTML = '';
            contentsContainer.innerHTML = '';
            
            const accountIds = Object.keys(depositsData);
            
            accountIds.forEach((accountIndex, i) => {
                const accountData = depositsData[accountIndex];
                const isFirst = i === 0;
                
                // Create tab
                const tab = document.createElement('div');
                tab.className = `tab ${isFirst ? 'active' : ''}`;
                tab.textContent = `Account #${accountIndex}`;
                tab.onclick = () => switchDepositsTab(accountIndex);
                tab.id = `deposits-tab-${accountIndex}`;
                tabsContainer.appendChild(tab);
                
                // Create content
                const content = document.createElement('div');
                content.className = `tab-content ${isFirst ? 'active' : ''}`;
                content.id = `deposits-content-${accountIndex}`;
                
                if (!accountData.success || accountData.deposits.length === 0) {
                    content.innerHTML = `<div class="error-message">No deposits found</div>`;
                } else {
                    const safeAccountIndex = parseInt(accountIndex, 10);
                    const safeTotal = parseInt(accountData.total_deposits, 10) || 0;
                    content.innerHTML = `
                        <div class="results-header">
                            <span class="results-stats">${safeTotal} deposits</span>
                            <div style="display: flex; gap: 8px;">
                                <button class="btn-secondary btn-small" onclick="exportDepositsCSV(${safeAccountIndex})">
                                    CSV
                                </button>
                                <button class="btn-secondary btn-small" onclick="exportDepositsJSON(${safeAccountIndex})">
                                    JSON
                                </button>
                            </div>
                        </div>
                        <div class="results-box">
                            ${buildDepositsTable(accountData.deposits)}
                        </div>
                    `;
                }
                
                contentsContainer.appendChild(content);
            });
        }
        
        // Build deposits table
        function buildDepositsTable(deposits) {
            let html = '<table class="trades-table"><thead><tr>';
            html += `<th>ID</th><th>Asset</th><th>Amount</th><th>Time (UTC)</th>
                <th><span class="header-with-info">Transaction Hash (L1)
                    <span class="info-icon">i<span class="info-tooltip">Deposits are always processed on Ethereum. If you select to deposit from different chains, Lighter will bridge them using e.g. CCTP</span></span>
                </span></th>`;
            html += '</tr></thead><tbody>';
            
            deposits.forEach(d => {
                const hash = d.l1_tx_hash || '';
                const shortHash = hash ? hash.substring(0, 16) + '...' : 'N/A';
                const safeHash = escapeHtml(hash);
                html += `<tr>
                    <td>${escapeHtml(d.id)}</td>
                    <td><span class="trade-market">${escapeHtml(d.asset)}</span></td>
                    <td>${escapeHtml(d.amount)}</td>
                    <td>${escapeHtml(d.datetime_utc)}</td>
                    <td>${hash ? `<span class="copyable" data-copy="${safeHash}" onclick="copyToClipboard(this)" title="Click to copy">
                        <span class="tx-hash">${escapeHtml(shortHash)}</span>${COPY_ICON_SVG}
                    </span>` : '<span class="tx-hash">N/A</span>'}</td>
                </tr>`;
            });
            
            html += '</tbody></table>';
            return html;
        }
        
        // Switch deposits tab
        function switchDepositsTab(accountIndex) {
            document.querySelectorAll('#depositsTabs .tab').forEach(t => t.classList.remove('active'));
            document.getElementById(`deposits-tab-${accountIndex}`).classList.add('active');
            
            document.querySelectorAll('#depositsContents .tab-content').forEach(c => c.classList.remove('active'));
            document.getElementById(`deposits-content-${accountIndex}`).classList.add('active');
        }
        
        // Export deposits as CSV
        function exportDepositsCSV(accountIndex) {
            const data = depositsData[accountIndex];
            if (!data || !data.deposits || data.deposits.length === 0) {
                alert('No deposits to export');
                return;
            }
            
            const headers = ['ID', 'Asset', 'Amount', 'Time (UTC)', 'Transaction Hash (L1)'];
            const csvRows = [headers.join(',')];
            
            data.deposits.forEach(d => {
                csvRows.push([
                    csvEscape(d.id),
                    csvEscape(d.asset),
                    csvEscape(d.amount),
                    csvEscape(d.datetime_utc),
                    csvEscape(d.l1_tx_hash)
                ].join(','));
            });
            
            const csvContent = csvRows.join('\n');
            const now = new Date();
            const timestamp = now.toISOString().replace(/[:.]/g, '-').slice(0, 19);
            const filename = `lighter_deposits_account_${accountIndex}_${timestamp}.csv`;
            
            const BOM = '\uFEFF';
            const encodedContent = encodeURIComponent(BOM + csvContent);
            const dataUri = `data:text/csv;charset=utf-8,${encodedContent}`;
            
            const a = document.createElement('a');
            a.href = dataUri;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            a.remove();
        }
        
        // Export deposits as JSON
        function exportDepositsJSON(accountIndex) {
            const rawDeposits = rawDepositsData[accountIndex];
            if (!rawDeposits || rawDeposits.length === 0) {
                alert('No deposits to export');
                return;
            }
            
            const jsonContent = JSON.stringify({
                exported_at: new Date().toISOString(),
                account_index: parseInt(accountIndex),
                total_deposits: rawDeposits.length,
                deposits: rawDeposits
            }, null, 2);
            
            const now = new Date();
            const timestamp = now.toISOString().replace(/[:.]/g, '-').slice(0, 19);
            const filename = `lighter_deposits_account_${accountIndex}_${timestamp}.json`;
            
            const blob = new Blob([jsonContent], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            
            setTimeout(() => {
                URL.revokeObjectURL(url);
                a.remove();
            }, 100);
        }
        
        // ===== TRANSFERS =====
        
        // Toggle transfer type filter
        function toggleTransferType(type) {
            transferTypeFilters[type] = !transferTypeFilters[type];
            
            // Update UI checkbox state
            const filterContainer = document.getElementById('transferTypeFilter');
            const labels = filterContainer.querySelectorAll('.column-option');
            labels.forEach(label => {
                const checkbox = label.querySelector('input');
                const labelText = label.textContent.trim();
                const mappedType = Object.entries(TRANSFER_TYPE_MAP).find(([k, v]) => v === labelText);
                if (mappedType) {
                    const isActive = transferTypeFilters[mappedType[0]];
                    checkbox.checked = isActive;
                    if (isActive) {
                        label.classList.add('active');
                    } else {
                        label.classList.remove('active');
                    }
                }
            });
            
            // Re-render if we have data
            if (Object.keys(transfersData).length > 0) {
                displayTransfersResults();
            }
        }
        
        // Toggle market type filter (Spot/Perp)
        function toggleMarketType(type) {
            marketTypeFilters[type] = !marketTypeFilters[type];
            
            // Update UI checkbox state
            const filterContainer = document.getElementById('marketTypeFilter');
            const labels = filterContainer.querySelectorAll('.column-option');
            labels.forEach(label => {
                const checkbox = label.querySelector('input');
                const labelText = label.textContent.trim();
                const typeKey = labelText === 'Perpetuals' ? 'Perp' : 'Spot';
                if ((type === 'Perp' && labelText === 'Perpetuals') || (type === 'Spot' && labelText === 'Spot')) {
                    const isActive = marketTypeFilters[type];
                    checkbox.checked = isActive;
                    if (isActive) {
                        label.classList.add('active');
                    } else {
                        label.classList.remove('active');
                    }
                }
            });
            
            // Re-render if we have data
            if (Object.keys(fetchedData).length > 0) {
                displayResults();
            }
        }
        
        // Get filtered trades based on market type filters
        function getFilteredTrades(trades) {
            return trades.filter(t => marketTypeFilters[t.market_type]);
        }
        
        // Fetch transfers from Lighter API
        // Transfers timestamp is in milliseconds
        // Transfers API: data comes in descending order (newest first)
        // We fetch from the beginning and stop when we hit events older than fromTimestamp (start date)
        async function fetchTransfersFromLighter(authToken, accountIndex, fromTimestamp = null, toTimestamp = null) {
            const allTransfers = [];
            let cursor = null;
            let page = 0;
            let reachedStart = false;
            
            while (true) {
                page++;
                const params = new URLSearchParams({
                    account_index: accountIndex
                });
                if (cursor) {
                    params.append('cursor', cursor);
                }
                
                const timeframeMsg = fromTimestamp ? ' (filtered)' : '';
                showStatus('fetchStatus', `Account #${accountIndex}: Fetching transfers page ${page}${timeframeMsg}...`, 'loading');
                
                try {
                    const response = await fetch(`${LIGHTER_API}/api/v1/transfer/history?${params}`, {
                        headers: { 'Authorization': authToken }
                    });
                    
                    if (response.status === 429) {
                        showStatus('fetchStatus', `Rate limited, waiting 15s...`, 'loading');
                        await new Promise(r => setTimeout(r, 15000));
                        continue;
                    }
                    
                    if (!response.ok) {
                        console.error(`HTTP error: ${response.status}`);
                        break;
                    }
                    
                    const data = await response.json();
                    if (data.code !== 200) {
                        console.error(`API error: ${data.code}`);
                        break;
                    }
                    
                    let transfers = data.transfers || [];
                    
                    // Data comes in descending order (newest first)
                    // If we have a start timestamp, stop when we hit events older than it
                    if (fromTimestamp && transfers.length > 0) {
                        const filteredTransfers = [];
                        for (const transfer of transfers) {
                            if (transfer.timestamp >= fromTimestamp) {
                                // Event is within range (newer than or equal to start date)
                                filteredTransfers.push(transfer);
                            } else {
                                // Event is older than start date - stop fetching
                                reachedStart = true;
                            }
                        }
                        transfers = filteredTransfers;
                    }
                    
                    allTransfers.push(...transfers);
                    
                    if (!data.cursor || transfers.length === 0 || reachedStart) {
                        break;
                    }
                    
                    cursor = data.cursor;
                    await new Promise(r => setTimeout(r, WALLET_RATE_LIMIT_DELAY));
                    
                } catch (error) {
                    console.error(`Error fetching transfers: ${error}`);
                    break;
                }
            }
            
            // Final filter to ensure all transfers are within the timeframe
            if (fromTimestamp || toTimestamp) {
                return allTransfers.filter(transfer => {
                    const afterStart = fromTimestamp ? transfer.timestamp >= fromTimestamp : true;
                    const beforeEnd = toTimestamp ? transfer.timestamp <= toTimestamp : true;
                    return afterStart && beforeEnd;
                });
            }
            
            return allTransfers;
        }
        
        // Fetch transfers for all selected accounts
        async function fetchTransfers() {
            if (!readOnlyToken) {
                showStatus('fetchStatus', 'Please enter a read-only token first', 'error');
                return;
            }
            
            const selectedAccounts = getSelectedAccounts();
            if (selectedAccounts.length === 0) {
                showStatus('fetchStatus', 'Please select at least one account', 'error');
                return;
            }
            
            // Validate timeframe
            if (!validateTimeframe()) {
                return;
            }
            
            const { fromTimestamp, toTimestamp } = getTimeframeParams();
            
            const btn = document.getElementById('fetchTransfersBtn');
            setAllFetchButtonsDisabled(true);
            btn.innerHTML = '<span class="spinner"></span>Fetching...';
            
            try {
                // Fetch asset details first
                await fetchAssetDetails();
                
                transfersData = {};
                rawTransfersData = {};
                
                for (const accountIndex of selectedAccounts) {
                    const rawTransfers = await fetchTransfersFromLighter(readOnlyToken, accountIndex, fromTimestamp, toTimestamp);
                    rawTransfersData[accountIndex] = rawTransfers;
                    
                    // Process transfers
                    const processed = processTransfers(rawTransfers);
                    transfersData[accountIndex] = {
                        success: true,
                        total_transfers: processed.length,
                        transfers: processed
                    };
                }
                
                let totalTransfers = 0;
                Object.values(transfersData).forEach(acc => {
                    totalTransfers += acc.total_transfers || 0;
                });
                
                showStatus('fetchStatus', `Successfully fetched ${totalTransfers} transfers`, 'success');
                displayTransfersResults();
                document.getElementById('transfersCard').classList.remove('hidden');
                
            } catch (error) {
                showStatus('fetchStatus', `Error: ${error.message}`, 'error');
            } finally {
                setAllFetchButtonsDisabled(false);
                btn.textContent = 'Fetch Transfers';
            }
        }
        
        // Process transfers data
        function processTransfers(rawTransfers) {
            return rawTransfers.map(t => {
                const timestamp = t.timestamp;
                const dt = new Date(timestamp);
                const dateStr = dt.toISOString().replace('T', ' ').slice(0, 19) + ' UTC';
                
                // Map type to friendly name
                const typeLabel = TRANSFER_TYPE_MAP[t.type] || t.type;
                
                return {
                    id: t.id,
                    asset: getAssetSymbol(t.asset_id),
                    amount: t.amount,
                    fee: t.fee,
                    datetime_utc: dateStr,
                    type: typeLabel,
                    raw_type: t.type, // Keep raw type for filtering
                    from_l1_address: t.from_l1_address,
                    to_l1_address: t.to_l1_address,
                    from_account_index: t.from_account_index,
                    to_account_index: t.to_account_index,
                    from_route: t.from_route,
                    to_route: t.to_route,
                    tx_hash: t.tx_hash
                };
            });
        }
        
        // Get filtered transfers based on type filters
        function getFilteredTransfers(transfers) {
            return transfers.filter(t => transferTypeFilters[t.raw_type]);
        }
        
        // Display transfers results
        function displayTransfersResults() {
            const tabsContainer = document.getElementById('transfersTabs');
            const contentsContainer = document.getElementById('transfersContents');
            tabsContainer.innerHTML = '';
            contentsContainer.innerHTML = '';
            
            const accountIds = Object.keys(transfersData);
            
            accountIds.forEach((accountIndex, i) => {
                const accountData = transfersData[accountIndex];
                const isFirst = i === 0;
                
                // Create tab
                const tab = document.createElement('div');
                tab.className = `tab ${isFirst ? 'active' : ''}`;
                tab.textContent = `Account #${accountIndex}`;
                tab.onclick = () => switchTransfersTab(accountIndex);
                tab.id = `transfers-tab-${accountIndex}`;
                tabsContainer.appendChild(tab);
                
                // Create content
                const content = document.createElement('div');
                content.className = `tab-content ${isFirst ? 'active' : ''}`;
                content.id = `transfers-content-${accountIndex}`;
                
                const filteredTransfers = getFilteredTransfers(accountData.transfers);
                
                if (!accountData.success || filteredTransfers.length === 0) {
                    content.innerHTML = `<div class="error-message">No transfers found (check type filters above)</div>`;
                } else {
                    const safeAccountIndex = parseInt(accountIndex, 10);
                    content.innerHTML = `
                        <div class="results-header">
                            <span class="results-stats">${filteredTransfers.length} transfers (${accountData.total_transfers} total)</span>
                            <div style="display: flex; gap: 8px;">
                                <button class="btn-secondary btn-small" onclick="exportTransfersCSV(${safeAccountIndex})">
                                    CSV
                                </button>
                                <button class="btn-secondary btn-small" onclick="exportTransfersJSON(${safeAccountIndex})">
                                    JSON
                                </button>
                            </div>
                        </div>
                        <div class="results-box">
                            ${buildTransfersTable(filteredTransfers)}
                        </div>
                    `;
                }
                
                contentsContainer.appendChild(content);
            });
        }
        
        // Build transfers table
        function buildTransfersTable(transfers) {
            let html = '<table class="trades-table"><thead><tr>';
            html += '<th>ID</th><th>Asset</th><th>Amount</th><th>Fee</th><th>Time (UTC)</th><th>Type</th>';
            html += `<th>From Address</th><th>To Address</th><th>From Account</th><th>To Account</th>
                <th>From Route</th><th>To Route</th>
                <th><span class="header-with-info">Transaction Hash (L2)
                    <span class="info-icon">i<span class="info-tooltip">These transactions are processed solely on Lighter's app-chain, to verify them you can use the <a href="https://app.lighter.xyz/explorer" target="_blank">Lighter explorer</a></span></span>
                </span></th>`;
            html += '</tr></thead><tbody>';
            
            transfers.forEach(t => {
                const fromAddr = t.from_l1_address || '';
                const toAddr = t.to_l1_address || '';
                const txHash = t.tx_hash || '';
                const shortFromAddr = fromAddr ? fromAddr.substring(0, 10) + '...' : 'N/A';
                const shortToAddr = toAddr ? toAddr.substring(0, 10) + '...' : 'N/A';
                const shortHash = txHash ? txHash.substring(0, 16) + '...' : 'N/A';
                
                // Color type based on direction
                let typeClass = '';
                if (t.type.includes('Outgoing') || t.type.includes('Mint')) {
                    typeClass = 'short'; // Red for outgoing
                } else if (t.type.includes('Incoming') || t.type.includes('Burn')) {
                    typeClass = 'long'; // Green for incoming
                }
                
                html += `<tr>
                    <td>${escapeHtml(t.id)}</td>
                    <td><span class="trade-market">${escapeHtml(t.asset)}</span></td>
                    <td>${escapeHtml(t.amount)}</td>
                    <td>${escapeHtml(t.fee)}</td>
                    <td>${escapeHtml(t.datetime_utc)}</td>
                    <td><span class="trade-side ${typeClass}">${escapeHtml(t.type)}</span></td>
                    <td>${fromAddr ? `<span class="copyable" data-copy="${escapeHtml(fromAddr)}" onclick="copyToClipboard(this)" title="Click to copy">
                        <span class="tx-hash">${escapeHtml(shortFromAddr)}</span>${COPY_ICON_SVG}
                    </span>` : '<span class="tx-hash">N/A</span>'}</td>
                    <td>${toAddr ? `<span class="copyable" data-copy="${escapeHtml(toAddr)}" onclick="copyToClipboard(this)" title="Click to copy">
                        <span class="tx-hash">${escapeHtml(shortToAddr)}</span>${COPY_ICON_SVG}
                    </span>` : '<span class="tx-hash">N/A</span>'}</td>
                    <td>${escapeHtml(t.from_account_index)}</td>
                    <td>${escapeHtml(t.to_account_index)}</td>
                    <td>${escapeHtml(t.from_route)}</td>
                    <td>${escapeHtml(t.to_route)}</td>
                    <td>${txHash ? `<span class="copyable" data-copy="${escapeHtml(txHash)}" onclick="copyToClipboard(this)" title="Click to copy">
                        <span class="tx-hash">${escapeHtml(shortHash)}</span>${COPY_ICON_SVG}
                    </span>` : '<span class="tx-hash">N/A</span>'}</td>
                </tr>`;
            });
            
            html += '</tbody></table>';
            return html;
        }
        
        // Switch transfers tab
        function switchTransfersTab(accountIndex) {
            document.querySelectorAll('#transfersTabs .tab').forEach(t => t.classList.remove('active'));
            document.getElementById(`transfers-tab-${accountIndex}`).classList.add('active');
            
            document.querySelectorAll('#transfersContents .tab-content').forEach(c => c.classList.remove('active'));
            document.getElementById(`transfers-content-${accountIndex}`).classList.add('active');
        }
        
        // Export transfers as CSV (only filtered types)
        function exportTransfersCSV(accountIndex) {
            const data = transfersData[accountIndex];
            if (!data || !data.transfers || data.transfers.length === 0) {
                alert('No transfers to export');
                return;
            }
            
            const filteredTransfers = getFilteredTransfers(data.transfers);
            if (filteredTransfers.length === 0) {
                alert('No transfers match the current type filters');
                return;
            }
            
            const headers = ['ID', 'Asset', 'Amount', 'Fee', 'Time (UTC)', 'Type', 'From Address', 'To Address', 'From Account', 'To Account', 'From Route', 'To Route', 'Transaction Hash (L2)'];
            const csvRows = [headers.join(',')];
            
            filteredTransfers.forEach(t => {
                csvRows.push([
                    csvEscape(t.id),
                    csvEscape(t.asset),
                    csvEscape(t.amount),
                    csvEscape(t.fee),
                    csvEscape(t.datetime_utc),
                    csvEscape(t.type),
                    csvEscape(t.from_l1_address),
                    csvEscape(t.to_l1_address),
                    csvEscape(t.from_account_index),
                    csvEscape(t.to_account_index),
                    csvEscape(t.from_route),
                    csvEscape(t.to_route),
                    csvEscape(t.tx_hash)
                ].join(','));
            });
            
            const csvContent = csvRows.join('\n');
            const now = new Date();
            const timestamp = now.toISOString().replace(/[:.]/g, '-').slice(0, 19);
            const filename = `lighter_transfers_account_${accountIndex}_${timestamp}.csv`;
            
            const BOM = '\uFEFF';
            const encodedContent = encodeURIComponent(BOM + csvContent);
            const dataUri = `data:text/csv;charset=utf-8,${encodedContent}`;
            
            const a = document.createElement('a');
            a.href = dataUri;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            a.remove();
        }
        
        // Export transfers as JSON
        function exportTransfersJSON(accountIndex) {
            const rawTransfers = rawTransfersData[accountIndex];
            if (!rawTransfers || rawTransfers.length === 0) {
                alert('No transfers to export');
                return;
            }
            
            const jsonContent = JSON.stringify({
                exported_at: new Date().toISOString(),
                account_index: parseInt(accountIndex),
                total_transfers: rawTransfers.length,
                transfers: rawTransfers
            }, null, 2);
            
            const now = new Date();
            const timestamp = now.toISOString().replace(/[:.]/g, '-').slice(0, 19);
            const filename = `lighter_transfers_account_${accountIndex}_${timestamp}.json`;
            
            const blob = new Blob([jsonContent], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            
            setTimeout(() => {
                URL.revokeObjectURL(url);
                a.remove();
            }, 100);
        }
        
        // ===== WITHDRAWALS =====
        
        // Fetch withdrawals from Lighter API
        // Withdrawals timestamp is in milliseconds
        // Withdrawals API: data comes in descending order (newest first)
        // We fetch from the beginning and stop when we hit events older than fromTimestamp (start date)
        async function fetchWithdrawalsFromLighter(authToken, accountIndex, fromTimestamp = null, toTimestamp = null) {
            const allWithdrawals = [];
            let cursor = null;
            let page = 0;
            let reachedStart = false;
            
            while (true) {
                page++;
                const params = new URLSearchParams({
                    account_index: accountIndex
                });
                if (cursor) {
                    params.append('cursor', cursor);
                }
                
                const timeframeMsg = fromTimestamp ? ' (filtered)' : '';
                showStatus('fetchStatus', `Account #${accountIndex}: Fetching withdrawals page ${page}${timeframeMsg}...`, 'loading');
                
                try {
                    const response = await fetch(`${LIGHTER_API}/api/v1/withdraw/history?${params}`, {
                        headers: { 'Authorization': authToken }
                    });
                    
                    if (response.status === 429) {
                        showStatus('fetchStatus', `Rate limited, waiting 15s...`, 'loading');
                        await new Promise(r => setTimeout(r, 15000));
                        continue;
                    }
                    
                    if (!response.ok) {
                        console.error(`HTTP error: ${response.status}`);
                        break;
                    }
                    
                    const data = await response.json();
                    if (data.code !== 200) {
                        console.error(`API error: ${data.code}`);
                        break;
                    }
                    
                    let withdrawals = data.withdraws || [];
                    
                    // Data comes in descending order (newest first)
                    // If we have a start timestamp, stop when we hit events older than it
                    if (fromTimestamp && withdrawals.length > 0) {
                        const filteredWithdrawals = [];
                        for (const withdrawal of withdrawals) {
                            if (withdrawal.timestamp >= fromTimestamp) {
                                // Event is within range (newer than or equal to start date)
                                filteredWithdrawals.push(withdrawal);
                            } else {
                                // Event is older than start date - stop fetching
                                reachedStart = true;
                            }
                        }
                        withdrawals = filteredWithdrawals;
                    }
                    
                    allWithdrawals.push(...withdrawals);
                    
                    if (!data.cursor || withdrawals.length === 0 || reachedStart) {
                        break;
                    }
                    
                    cursor = data.cursor;
                    await new Promise(r => setTimeout(r, WALLET_RATE_LIMIT_DELAY));
                    
                } catch (error) {
                    console.error(`Error fetching withdrawals: ${error}`);
                    break;
                }
            }
            
            // Final filter to ensure all withdrawals are within the timeframe
            if (fromTimestamp || toTimestamp) {
                return allWithdrawals.filter(withdrawal => {
                    const afterStart = fromTimestamp ? withdrawal.timestamp >= fromTimestamp : true;
                    const beforeEnd = toTimestamp ? withdrawal.timestamp <= toTimestamp : true;
                    return afterStart && beforeEnd;
                });
            }
            
            return allWithdrawals;
        }
        
        // Fetch withdrawals for all selected accounts
        async function fetchWithdrawals() {
            if (!readOnlyToken) {
                showStatus('fetchStatus', 'Please enter a read-only token first', 'error');
                return;
            }
            
            const selectedAccounts = getSelectedAccounts();
            if (selectedAccounts.length === 0) {
                showStatus('fetchStatus', 'Please select at least one account', 'error');
                return;
            }
            
            // Validate timeframe
            if (!validateTimeframe()) {
                return;
            }
            
            const { fromTimestamp, toTimestamp } = getTimeframeParams();
            
            const btn = document.getElementById('fetchWithdrawalsBtn');
            setAllFetchButtonsDisabled(true);
            btn.innerHTML = '<span class="spinner"></span>Fetching...';
            
            try {
                // Fetch asset details first
                await fetchAssetDetails();
                
                withdrawalsData = {};
                rawWithdrawalsData = {};
                
                for (const accountIndex of selectedAccounts) {
                    const rawWithdrawals = await fetchWithdrawalsFromLighter(readOnlyToken, accountIndex, fromTimestamp, toTimestamp);
                    rawWithdrawalsData[accountIndex] = rawWithdrawals;
                    
                    // Process withdrawals
                    const processed = processWithdrawals(rawWithdrawals);
                    withdrawalsData[accountIndex] = {
                        success: true,
                        total_withdrawals: processed.length,
                        withdrawals: processed
                    };
                }
                
                let totalWithdrawals = 0;
                Object.values(withdrawalsData).forEach(acc => {
                    totalWithdrawals += acc.total_withdrawals || 0;
                });
                
                showStatus('fetchStatus', `Successfully fetched ${totalWithdrawals} withdrawals`, 'success');
                displayWithdrawalsResults();
                document.getElementById('withdrawalsCard').classList.remove('hidden');
                
            } catch (error) {
                showStatus('fetchStatus', `Error: ${error.message}`, 'error');
            } finally {
                setAllFetchButtonsDisabled(false);
                btn.textContent = 'Fetch Withdrawals';
            }
        }
        
        // Process withdrawals data
        function processWithdrawals(rawWithdrawals) {
            return rawWithdrawals.map(w => {
                const timestamp = w.timestamp;
                const dt = new Date(timestamp);
                const dateStr = dt.toISOString().replace('T', ' ').slice(0, 19) + ' UTC';
                
                return {
                    id: w.id,
                    asset: getAssetSymbol(w.asset_id),
                    amount: w.amount,
                    datetime_utc: dateStr,
                    l1_tx_hash: w.l1_tx_hash
                };
            });
        }
        
        // Display withdrawals results
        function displayWithdrawalsResults() {
            const tabsContainer = document.getElementById('withdrawalsTabs');
            const contentsContainer = document.getElementById('withdrawalsContents');
            tabsContainer.innerHTML = '';
            contentsContainer.innerHTML = '';
            
            const accountIds = Object.keys(withdrawalsData);
            
            accountIds.forEach((accountIndex, i) => {
                const accountData = withdrawalsData[accountIndex];
                const isFirst = i === 0;
                
                // Create tab
                const tab = document.createElement('div');
                tab.className = `tab ${isFirst ? 'active' : ''}`;
                tab.textContent = `Account #${accountIndex}`;
                tab.onclick = () => switchWithdrawalsTab(accountIndex);
                tab.id = `withdrawals-tab-${accountIndex}`;
                tabsContainer.appendChild(tab);
                
                // Create content
                const content = document.createElement('div');
                content.className = `tab-content ${isFirst ? 'active' : ''}`;
                content.id = `withdrawals-content-${accountIndex}`;
                
                if (!accountData.success || accountData.withdrawals.length === 0) {
                    content.innerHTML = `<div class="error-message">No withdrawals found</div>`;
                } else {
                    const safeAccountIndex = parseInt(accountIndex, 10);
                    const safeTotal = parseInt(accountData.total_withdrawals, 10) || 0;
                    content.innerHTML = `
                        <div class="results-header">
                            <span class="results-stats">${safeTotal} withdrawals</span>
                            <div style="display: flex; gap: 8px;">
                                <button class="btn-secondary btn-small" onclick="exportWithdrawalsCSV(${safeAccountIndex})">
                                    CSV
                                </button>
                                <button class="btn-secondary btn-small" onclick="exportWithdrawalsJSON(${safeAccountIndex})">
                                    JSON
                                </button>
                            </div>
                        </div>
                        <div class="results-box">
                            ${buildWithdrawalsTable(accountData.withdrawals)}
                        </div>
                    `;
                }
                
                contentsContainer.appendChild(content);
            });
        }
        
        // Build withdrawals table
        function buildWithdrawalsTable(withdrawals) {
            let html = '<table class="trades-table"><thead><tr>';
            html += `<th>ID</th><th>Asset</th><th>Amount</th><th>Time (UTC)</th>
                <th><span class="header-with-info">Transaction Hash
                    <span class="info-icon">i<span class="info-tooltip">These transactions can be processed on both Ethereum and Arbitrum. If the ID starts with "fast", that means the withdraw was processed to Arbitrum</span></span>
                </span></th>`;
            html += '</tr></thead><tbody>';
            
            withdrawals.forEach(w => {
                const hash = w.l1_tx_hash || '';
                const shortHash = hash ? hash.substring(0, 16) + '...' : 'N/A';
                html += `<tr>
                    <td>${escapeHtml(w.id)}</td>
                    <td><span class="trade-market">${escapeHtml(w.asset)}</span></td>
                    <td>${escapeHtml(w.amount)}</td>
                    <td>${escapeHtml(w.datetime_utc)}</td>
                    <td>${hash ? `<span class="copyable" data-copy="${escapeHtml(hash)}" onclick="copyToClipboard(this)" title="Click to copy">
                        <span class="tx-hash">${escapeHtml(shortHash)}</span>${COPY_ICON_SVG}
                    </span>` : '<span class="tx-hash">N/A</span>'}</td>
                </tr>`;
            });
            
            html += '</tbody></table>';
            return html;
        }
        
        // Switch withdrawals tab
        function switchWithdrawalsTab(accountIndex) {
            document.querySelectorAll('#withdrawalsTabs .tab').forEach(t => t.classList.remove('active'));
            document.getElementById(`withdrawals-tab-${accountIndex}`).classList.add('active');
            
            document.querySelectorAll('#withdrawalsContents .tab-content').forEach(c => c.classList.remove('active'));
            document.getElementById(`withdrawals-content-${accountIndex}`).classList.add('active');
        }
        
        // Export withdrawals as CSV
        function exportWithdrawalsCSV(accountIndex) {
            const data = withdrawalsData[accountIndex];
            if (!data || !data.withdrawals || data.withdrawals.length === 0) {
                alert('No withdrawals to export');
                return;
            }
            
            const headers = ['ID', 'Asset', 'Amount', 'Time (UTC)', 'Transaction Hash'];
            const csvRows = [headers.join(',')];
            
            data.withdrawals.forEach(w => {
                csvRows.push([
                    csvEscape(w.id),
                    csvEscape(w.asset),
                    csvEscape(w.amount),
                    csvEscape(w.datetime_utc),
                    csvEscape(w.l1_tx_hash)
                ].join(','));
            });
            
            const csvContent = csvRows.join('\n');
            const now = new Date();
            const timestamp = now.toISOString().replace(/[:.]/g, '-').slice(0, 19);
            const filename = `lighter_withdrawals_account_${accountIndex}_${timestamp}.csv`;
            
            const BOM = '\uFEFF';
            const encodedContent = encodeURIComponent(BOM + csvContent);
            const dataUri = `data:text/csv;charset=utf-8,${encodedContent}`;
            
            const a = document.createElement('a');
            a.href = dataUri;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            a.remove();
        }
        
        // Export withdrawals as JSON
        function exportWithdrawalsJSON(accountIndex) {
            const rawWithdrawals = rawWithdrawalsData[accountIndex];
            if (!rawWithdrawals || rawWithdrawals.length === 0) {
                alert('No withdrawals to export');
                return;
            }
            
            const jsonContent = JSON.stringify({
                exported_at: new Date().toISOString(),
                account_index: parseInt(accountIndex),
                total_withdrawals: rawWithdrawals.length,
                withdrawals: rawWithdrawals
            }, null, 2);
            
            const now = new Date();
            const timestamp = now.toISOString().replace(/[:.]/g, '-').slice(0, 19);
            const filename = `lighter_withdrawals_account_${accountIndex}_${timestamp}.json`;
            
            const blob = new Blob([jsonContent], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            
            setTimeout(() => {
                URL.revokeObjectURL(url);
                a.remove();
            }, 100);
        }
        
        // Initialize on page load
        initColumnSelection();
    </script>
</body>
</html>
